# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator 0.17.0.0
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Azure::ARM::DataLakeStore::FileSystem
  #
  # Creates an Azure Data Lake Store filesystem client.
  #
  class FileSystem
    include Azure::ARM::DataLakeStore::FileSystem::Models
    include MsRestAzure

    #
    # Creates and initializes a new instance of the FileSystem class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
      @client = client
    end

    # @return reference to the DataLakeStoreFileSystemManagementClient
    attr_reader :client

    #
    # Appends to the specified file. This method supports multiple concurrent
    # appends to the file. NOTE: Concurrent append and normal (serial) append
    # CANNOT be used interchangeably. Once a file has been appended to using
    # either append option, it can only be appended to using that append option.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param file_path [String] The Data Lake Store path (starting with '/') of
    # the file to which to append using concurrent append.
    # @param stream_contents The file contents to include when appending to the
    # file.
    # @param append_mode [AppendModeType] Indicates the concurrent append call
    # should create the file if it doesn't exist or just open the existing file
    # for append. Possible values include: 'autocreate'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def concurrent_append(account_name, file_path, stream_contents, append_mode = nil, custom_headers = nil)
      response = concurrent_append_async(account_name, file_path, stream_contents, append_mode, custom_headers).value!
      nil
    end

    #
    # Appends to the specified file. This method supports multiple concurrent
    # appends to the file. NOTE: Concurrent append and normal (serial) append
    # CANNOT be used interchangeably. Once a file has been appended to using
    # either append option, it can only be appended to using that append option.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param file_path [String] The Data Lake Store path (starting with '/') of
    # the file to which to append using concurrent append.
    # @param stream_contents The file contents to include when appending to the
    # file.
    # @param append_mode [AppendModeType] Indicates the concurrent append call
    # should create the file if it doesn't exist or just open the existing file
    # for append. Possible values include: 'autocreate'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def concurrent_append_with_http_info(account_name, file_path, stream_contents, append_mode = nil, custom_headers = nil)
      concurrent_append_async(account_name, file_path, stream_contents, append_mode, custom_headers).value!
    end

    #
    # Appends to the specified file. This method supports multiple concurrent
    # appends to the file. NOTE: Concurrent append and normal (serial) append
    # CANNOT be used interchangeably. Once a file has been appended to using
    # either append option, it can only be appended to using that append option.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param file_path [String] The Data Lake Store path (starting with '/') of
    # the file to which to append using concurrent append.
    # @param stream_contents The file contents to include when appending to the
    # file.
    # @param append_mode [AppendModeType] Indicates the concurrent append call
    # should create the file if it doesn't exist or just open the existing file
    # for append. Possible values include: 'autocreate'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def concurrent_append_async(account_name, file_path, stream_contents, append_mode = nil, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'file_path is nil' if file_path.nil?
      fail ArgumentError, 'stream_contents is nil' if stream_contents.nil?
      op = 'CONCURRENTAPPEND'
      transfer_encoding = 'chunked'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['Transfer-Encoding'] = transfer_encoding unless transfer_encoding.nil?
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/octet-stream'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'streamContents',
        type: {
          name: 'Stream'
        }
      }
      request_content = @client.serialize(request_mapper,  stream_contents, 'stream_contents')
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = '/WebHdfsExt/{filePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'filePath' => file_path},
          query_params: {'appendMode' => append_mode,'op' => op,'api-version' => @client.api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :post, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Checks if the specified access is available at the given path.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param path [String] The Data Lake Store path (starting with '/') of the
    # file or directory for which to check access.
    # @param fsaction [String] File system operation read/write/execute in string
    # form, matching regex pattern '[rwx-]{3}'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def check_access(account_name, path, fsaction = nil, custom_headers = nil)
      response = check_access_async(account_name, path, fsaction, custom_headers).value!
      nil
    end

    #
    # Checks if the specified access is available at the given path.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param path [String] The Data Lake Store path (starting with '/') of the
    # file or directory for which to check access.
    # @param fsaction [String] File system operation read/write/execute in string
    # form, matching regex pattern '[rwx-]{3}'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def check_access_with_http_info(account_name, path, fsaction = nil, custom_headers = nil)
      check_access_async(account_name, path, fsaction, custom_headers).value!
    end

    #
    # Checks if the specified access is available at the given path.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param path [String] The Data Lake Store path (starting with '/') of the
    # file or directory for which to check access.
    # @param fsaction [String] File system operation read/write/execute in string
    # form, matching regex pattern '[rwx-]{3}'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def check_access_async(account_name, path, fsaction = nil, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'path is nil' if path.nil?
      op = 'CHECKACCESS'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{path}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'path' => path},
          query_params: {'fsaction' => fsaction,'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :get, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Creates a directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param path [String] The Data Lake Store path (starting with '/') of the
    # directory to create.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FileOperationResult] operation results.
    #
    def mkdirs(account_name, path, custom_headers = nil)
      response = mkdirs_async(account_name, path, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param path [String] The Data Lake Store path (starting with '/') of the
    # directory to create.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def mkdirs_with_http_info(account_name, path, custom_headers = nil)
      mkdirs_async(account_name, path, custom_headers).value!
    end

    #
    # Creates a directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param path [String] The Data Lake Store path (starting with '/') of the
    # directory to create.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def mkdirs_async(account_name, path, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'path is nil' if path.nil?
      op = 'MKDIRS'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{path}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'path' => path},
          query_params: {'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :put, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = FileOperationResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response, 'result.body')
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Concatenates the list of source files into the destination file, removing
    # all source files upon success.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param destination_path [String] The Data Lake Store path (starting with
    # '/') of the destination file resulting from the concatenation.
    # @param sources [Array<String>] A list of comma seperated Data Lake Store
    # paths (starting with '/') of the files to concatenate, in the order in
    # which they should be concatenated.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def concat(account_name, destination_path, sources, custom_headers = nil)
      response = concat_async(account_name, destination_path, sources, custom_headers).value!
      nil
    end

    #
    # Concatenates the list of source files into the destination file, removing
    # all source files upon success.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param destination_path [String] The Data Lake Store path (starting with
    # '/') of the destination file resulting from the concatenation.
    # @param sources [Array<String>] A list of comma seperated Data Lake Store
    # paths (starting with '/') of the files to concatenate, in the order in
    # which they should be concatenated.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def concat_with_http_info(account_name, destination_path, sources, custom_headers = nil)
      concat_async(account_name, destination_path, sources, custom_headers).value!
    end

    #
    # Concatenates the list of source files into the destination file, removing
    # all source files upon success.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param destination_path [String] The Data Lake Store path (starting with
    # '/') of the destination file resulting from the concatenation.
    # @param sources [Array<String>] A list of comma seperated Data Lake Store
    # paths (starting with '/') of the files to concatenate, in the order in
    # which they should be concatenated.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def concat_async(account_name, destination_path, sources, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'destination_path is nil' if destination_path.nil?
      fail ArgumentError, 'sources is nil' if sources.nil?
      op = 'CONCAT'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{destinationPath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'destinationPath' => destination_path},
          query_params: {'sources' => sources.nil? ? nil : sources.join(','),'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :post, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Concatenates the list of source files into the destination file, deleting
    # all source files upon success. This method accepts more source file paths
    # than the Concat method. This method and the parameters it accepts are
    # subject to change for usability in an upcoming version.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param ms_concat_destination_path [String] The Data Lake Store path
    # (starting with '/') of the destination file resulting from the
    # concatenation.
    # @param stream_contents A list of Data Lake Store paths (starting with '/')
    # of the source files. Must be in the format: sources=<comma separated list>
    # @param delete_source_directory [Boolean] Indicates that as an optimization
    # instead of deleting each individual source stream, delete the source stream
    # folder if all streams are in the same folder instead. This results in a
    # substantial performance improvement when the only streams in the folder are
    # part of the concatenation operation. WARNING: This includes the deletion of
    # any other files that are not source files. Only set this to true when
    # source files are the only files in the source directory.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def ms_concat(account_name, ms_concat_destination_path, stream_contents, delete_source_directory = nil, custom_headers = nil)
      response = ms_concat_async(account_name, ms_concat_destination_path, stream_contents, delete_source_directory, custom_headers).value!
      nil
    end

    #
    # Concatenates the list of source files into the destination file, deleting
    # all source files upon success. This method accepts more source file paths
    # than the Concat method. This method and the parameters it accepts are
    # subject to change for usability in an upcoming version.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param ms_concat_destination_path [String] The Data Lake Store path
    # (starting with '/') of the destination file resulting from the
    # concatenation.
    # @param stream_contents A list of Data Lake Store paths (starting with '/')
    # of the source files. Must be in the format: sources=<comma separated list>
    # @param delete_source_directory [Boolean] Indicates that as an optimization
    # instead of deleting each individual source stream, delete the source stream
    # folder if all streams are in the same folder instead. This results in a
    # substantial performance improvement when the only streams in the folder are
    # part of the concatenation operation. WARNING: This includes the deletion of
    # any other files that are not source files. Only set this to true when
    # source files are the only files in the source directory.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def ms_concat_with_http_info(account_name, ms_concat_destination_path, stream_contents, delete_source_directory = nil, custom_headers = nil)
      ms_concat_async(account_name, ms_concat_destination_path, stream_contents, delete_source_directory, custom_headers).value!
    end

    #
    # Concatenates the list of source files into the destination file, deleting
    # all source files upon success. This method accepts more source file paths
    # than the Concat method. This method and the parameters it accepts are
    # subject to change for usability in an upcoming version.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param ms_concat_destination_path [String] The Data Lake Store path
    # (starting with '/') of the destination file resulting from the
    # concatenation.
    # @param stream_contents A list of Data Lake Store paths (starting with '/')
    # of the source files. Must be in the format: sources=<comma separated list>
    # @param delete_source_directory [Boolean] Indicates that as an optimization
    # instead of deleting each individual source stream, delete the source stream
    # folder if all streams are in the same folder instead. This results in a
    # substantial performance improvement when the only streams in the folder are
    # part of the concatenation operation. WARNING: This includes the deletion of
    # any other files that are not source files. Only set this to true when
    # source files are the only files in the source directory.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def ms_concat_async(account_name, ms_concat_destination_path, stream_contents, delete_source_directory = nil, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'ms_concat_destination_path is nil' if ms_concat_destination_path.nil?
      fail ArgumentError, 'stream_contents is nil' if stream_contents.nil?
      op = 'MSCONCAT'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/octet-stream'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'streamContents',
        type: {
          name: 'Stream'
        }
      }
      request_content = @client.serialize(request_mapper,  stream_contents, 'stream_contents')
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = '/webhdfs/v1/{msConcatDestinationPath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'msConcatDestinationPath' => ms_concat_destination_path},
          query_params: {'deleteSourceDirectory' => delete_source_directory,'op' => op,'api-version' => @client.api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :post, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Get the list of file status objects specified by the file path, with
    # optional pagination parameters
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param list_file_path [String] The Data Lake Store path (starting with '/')
    # of the directory to list.
    # @param list_size [Integer] Gets or sets the number of items to return.
    # Optional.
    # @param list_after [String] Gets or sets the item or lexographical index
    # after which to begin returning results. For example, a file list of
    # 'a','b','d' and listAfter='b' will return 'd', and a listAfter='c' will
    # also return 'd'. Optional.
    # @param list_before [String] Gets or sets the item or lexographical index
    # before which to begin returning results. For example, a file list of
    # 'a','b','d' and listBefore='d' will return 'a','b', and a listBefore='c'
    # will also return 'a','b'. Optional.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FileStatusesResult] operation results.
    #
    def list_file_status(account_name, list_file_path, list_size = nil, list_after = nil, list_before = nil, custom_headers = nil)
      response = list_file_status_async(account_name, list_file_path, list_size, list_after, list_before, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get the list of file status objects specified by the file path, with
    # optional pagination parameters
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param list_file_path [String] The Data Lake Store path (starting with '/')
    # of the directory to list.
    # @param list_size [Integer] Gets or sets the number of items to return.
    # Optional.
    # @param list_after [String] Gets or sets the item or lexographical index
    # after which to begin returning results. For example, a file list of
    # 'a','b','d' and listAfter='b' will return 'd', and a listAfter='c' will
    # also return 'd'. Optional.
    # @param list_before [String] Gets or sets the item or lexographical index
    # before which to begin returning results. For example, a file list of
    # 'a','b','d' and listBefore='d' will return 'a','b', and a listBefore='c'
    # will also return 'a','b'. Optional.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def list_file_status_with_http_info(account_name, list_file_path, list_size = nil, list_after = nil, list_before = nil, custom_headers = nil)
      list_file_status_async(account_name, list_file_path, list_size, list_after, list_before, custom_headers).value!
    end

    #
    # Get the list of file status objects specified by the file path, with
    # optional pagination parameters
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param list_file_path [String] The Data Lake Store path (starting with '/')
    # of the directory to list.
    # @param list_size [Integer] Gets or sets the number of items to return.
    # Optional.
    # @param list_after [String] Gets or sets the item or lexographical index
    # after which to begin returning results. For example, a file list of
    # 'a','b','d' and listAfter='b' will return 'd', and a listAfter='c' will
    # also return 'd'. Optional.
    # @param list_before [String] Gets or sets the item or lexographical index
    # before which to begin returning results. For example, a file list of
    # 'a','b','d' and listBefore='d' will return 'a','b', and a listBefore='c'
    # will also return 'a','b'. Optional.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_file_status_async(account_name, list_file_path, list_size = nil, list_after = nil, list_before = nil, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'list_file_path is nil' if list_file_path.nil?
      op = 'MSLISTSTATUS'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{listFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'listFilePath' => list_file_path},
          query_params: {'listSize' => list_size,'listAfter' => list_after,'listBefore' => list_before,'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :get, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = FileStatusesResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response, 'result.body')
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets the file content summary object specified by the file path.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param get_content_summary_file_path [String] The Data Lake Store path
    # (starting with '/') of the file for which to retrieve the summary.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ContentSummaryResult] operation results.
    #
    def get_content_summary(account_name, get_content_summary_file_path, custom_headers = nil)
      response = get_content_summary_async(account_name, get_content_summary_file_path, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets the file content summary object specified by the file path.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param get_content_summary_file_path [String] The Data Lake Store path
    # (starting with '/') of the file for which to retrieve the summary.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_content_summary_with_http_info(account_name, get_content_summary_file_path, custom_headers = nil)
      get_content_summary_async(account_name, get_content_summary_file_path, custom_headers).value!
    end

    #
    # Gets the file content summary object specified by the file path.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param get_content_summary_file_path [String] The Data Lake Store path
    # (starting with '/') of the file for which to retrieve the summary.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_content_summary_async(account_name, get_content_summary_file_path, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'get_content_summary_file_path is nil' if get_content_summary_file_path.nil?
      op = 'GETCONTENTSUMMARY'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/va/{getContentSummaryFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'getContentSummaryFilePath' => get_content_summary_file_path},
          query_params: {'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :get, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = ContentSummaryResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response, 'result.body')
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get the file status object specified by the file path.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param get_file_path [String] The Data Lake Store path (starting with '/')
    # of the file or directory for which to retrieve the status.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FileStatusResult] operation results.
    #
    def get_file_status(account_name, get_file_path, custom_headers = nil)
      response = get_file_status_async(account_name, get_file_path, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get the file status object specified by the file path.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param get_file_path [String] The Data Lake Store path (starting with '/')
    # of the file or directory for which to retrieve the status.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_file_status_with_http_info(account_name, get_file_path, custom_headers = nil)
      get_file_status_async(account_name, get_file_path, custom_headers).value!
    end

    #
    # Get the file status object specified by the file path.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param get_file_path [String] The Data Lake Store path (starting with '/')
    # of the file or directory for which to retrieve the status.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_file_status_async(account_name, get_file_path, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'get_file_path is nil' if get_file_path.nil?
      op = 'GETFILESTATUS'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{getFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'getFilePath' => get_file_path},
          query_params: {'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :get, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = FileStatusResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response, 'result.body')
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Appends to the specified file. This method does not support multiple
    # concurrent appends to the file. NOTE: Concurrent append and normal (serial)
    # append CANNOT be used interchangeably. Once a file has been appended to
    # using either append option, it can only be appended to using that append
    # option. Use the ConcurrentAppend option if you would like support for
    # concurrent appends.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param direct_file_path [String] The Data Lake Store path (starting with
    # '/') of the file to which to append.
    # @param stream_contents The file contents to include when appending to the
    # file.
    # @param offset [Integer] The optional offset in the stream to begin the
    # append operation. Default is to append at the end of the stream.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def append(account_name, direct_file_path, stream_contents, offset = nil, custom_headers = nil)
      response = append_async(account_name, direct_file_path, stream_contents, offset, custom_headers).value!
      nil
    end

    #
    # Appends to the specified file. This method does not support multiple
    # concurrent appends to the file. NOTE: Concurrent append and normal (serial)
    # append CANNOT be used interchangeably. Once a file has been appended to
    # using either append option, it can only be appended to using that append
    # option. Use the ConcurrentAppend option if you would like support for
    # concurrent appends.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param direct_file_path [String] The Data Lake Store path (starting with
    # '/') of the file to which to append.
    # @param stream_contents The file contents to include when appending to the
    # file.
    # @param offset [Integer] The optional offset in the stream to begin the
    # append operation. Default is to append at the end of the stream.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def append_with_http_info(account_name, direct_file_path, stream_contents, offset = nil, custom_headers = nil)
      append_async(account_name, direct_file_path, stream_contents, offset, custom_headers).value!
    end

    #
    # Appends to the specified file. This method does not support multiple
    # concurrent appends to the file. NOTE: Concurrent append and normal (serial)
    # append CANNOT be used interchangeably. Once a file has been appended to
    # using either append option, it can only be appended to using that append
    # option. Use the ConcurrentAppend option if you would like support for
    # concurrent appends.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param direct_file_path [String] The Data Lake Store path (starting with
    # '/') of the file to which to append.
    # @param stream_contents The file contents to include when appending to the
    # file.
    # @param offset [Integer] The optional offset in the stream to begin the
    # append operation. Default is to append at the end of the stream.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def append_async(account_name, direct_file_path, stream_contents, offset = nil, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'direct_file_path is nil' if direct_file_path.nil?
      fail ArgumentError, 'stream_contents is nil' if stream_contents.nil?
      op = 'APPEND'
      append = 'true'
      transfer_encoding = 'chunked'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['Transfer-Encoding'] = transfer_encoding unless transfer_encoding.nil?
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/octet-stream'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'streamContents',
        type: {
          name: 'Stream'
        }
      }
      request_content = @client.serialize(request_mapper,  stream_contents, 'stream_contents')
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = '/webhdfs/v1/{directFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'directFilePath' => direct_file_path},
          query_params: {'offset' => offset,'op' => op,'append' => append,'api-version' => @client.api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :post, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Creates a file with optionally specified content.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param direct_file_path [String] The Data Lake Store path (starting with
    # '/') of the file to create.
    # @param stream_contents The file contents to include when creating the file.
    # This parameter is optional, resulting in an empty file if not specified.
    # @param overwrite [Boolean] The indication of if the file should be
    # overwritten.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def create(account_name, direct_file_path, stream_contents = nil, overwrite = nil, custom_headers = nil)
      response = create_async(account_name, direct_file_path, stream_contents, overwrite, custom_headers).value!
      nil
    end

    #
    # Creates a file with optionally specified content.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param direct_file_path [String] The Data Lake Store path (starting with
    # '/') of the file to create.
    # @param stream_contents The file contents to include when creating the file.
    # This parameter is optional, resulting in an empty file if not specified.
    # @param overwrite [Boolean] The indication of if the file should be
    # overwritten.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def create_with_http_info(account_name, direct_file_path, stream_contents = nil, overwrite = nil, custom_headers = nil)
      create_async(account_name, direct_file_path, stream_contents, overwrite, custom_headers).value!
    end

    #
    # Creates a file with optionally specified content.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param direct_file_path [String] The Data Lake Store path (starting with
    # '/') of the file to create.
    # @param stream_contents The file contents to include when creating the file.
    # This parameter is optional, resulting in an empty file if not specified.
    # @param overwrite [Boolean] The indication of if the file should be
    # overwritten.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_async(account_name, direct_file_path, stream_contents = nil, overwrite = nil, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'direct_file_path is nil' if direct_file_path.nil?
      op = 'CREATE'
      write = 'true'
      transfer_encoding = 'chunked'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['Transfer-Encoding'] = transfer_encoding unless transfer_encoding.nil?
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/octet-stream'

      # Serialize Request
      request_mapper = {
        required: false,
        serialized_name: 'streamContents',
        type: {
          name: 'Stream'
        }
      }
      request_content = @client.serialize(request_mapper,  stream_contents, 'stream_contents')
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = '/webhdfs/v1/{directFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'directFilePath' => direct_file_path},
          query_params: {'overwrite' => overwrite,'op' => op,'write' => write,'api-version' => @client.api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :put, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Opens and reads from the specified file.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param direct_file_path [String] The Data Lake Store path (starting with
    # '/') of the file to open.
    # @param length [Integer]
    # @param offset [Integer]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [System.IO.Stream] operation results.
    #
    def open(account_name, direct_file_path, length = nil, offset = nil, custom_headers = nil)
      response = open_async(account_name, direct_file_path, length, offset, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Opens and reads from the specified file.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param direct_file_path [String] The Data Lake Store path (starting with
    # '/') of the file to open.
    # @param length [Integer]
    # @param offset [Integer]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def open_with_http_info(account_name, direct_file_path, length = nil, offset = nil, custom_headers = nil)
      open_async(account_name, direct_file_path, length, offset, custom_headers).value!
    end

    #
    # Opens and reads from the specified file.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param direct_file_path [String] The Data Lake Store path (starting with
    # '/') of the file to open.
    # @param length [Integer]
    # @param offset [Integer]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def open_async(account_name, direct_file_path, length = nil, offset = nil, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'direct_file_path is nil' if direct_file_path.nil?
      op = 'OPEN'
      read = 'true'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{directFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'directFilePath' => direct_file_path},
          query_params: {'length' => length,'offset' => offset,'op' => op,'read' => read,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :get, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Stream'
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response, 'result.body')
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Sets the Access Control List (ACL) for a file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param set_acl_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory on which to set the ACL.
    # @param aclspec [String] The ACL spec included in ACL creation operations in
    # the format '[default:]user|group|other::r|-w|-x|-'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def set_acl(account_name, set_acl_file_path, aclspec, custom_headers = nil)
      response = set_acl_async(account_name, set_acl_file_path, aclspec, custom_headers).value!
      nil
    end

    #
    # Sets the Access Control List (ACL) for a file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param set_acl_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory on which to set the ACL.
    # @param aclspec [String] The ACL spec included in ACL creation operations in
    # the format '[default:]user|group|other::r|-w|-x|-'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def set_acl_with_http_info(account_name, set_acl_file_path, aclspec, custom_headers = nil)
      set_acl_async(account_name, set_acl_file_path, aclspec, custom_headers).value!
    end

    #
    # Sets the Access Control List (ACL) for a file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param set_acl_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory on which to set the ACL.
    # @param aclspec [String] The ACL spec included in ACL creation operations in
    # the format '[default:]user|group|other::r|-w|-x|-'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def set_acl_async(account_name, set_acl_file_path, aclspec, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'set_acl_file_path is nil' if set_acl_file_path.nil?
      fail ArgumentError, 'aclspec is nil' if aclspec.nil?
      op = 'SETACL'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{setAclFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'setAclFilePath' => set_acl_file_path},
          query_params: {'aclspec' => aclspec,'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :put, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Modifies existing Access Control List (ACL) entries on a file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param modify_acl_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory with the ACL being modified.
    # @param aclspec [String] The ACL specification included in ACL modification
    # operations in the format '[default:]user|group|other::r|-w|-x|-'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def modify_acl_entries(account_name, modify_acl_file_path, aclspec, custom_headers = nil)
      response = modify_acl_entries_async(account_name, modify_acl_file_path, aclspec, custom_headers).value!
      nil
    end

    #
    # Modifies existing Access Control List (ACL) entries on a file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param modify_acl_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory with the ACL being modified.
    # @param aclspec [String] The ACL specification included in ACL modification
    # operations in the format '[default:]user|group|other::r|-w|-x|-'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def modify_acl_entries_with_http_info(account_name, modify_acl_file_path, aclspec, custom_headers = nil)
      modify_acl_entries_async(account_name, modify_acl_file_path, aclspec, custom_headers).value!
    end

    #
    # Modifies existing Access Control List (ACL) entries on a file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param modify_acl_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory with the ACL being modified.
    # @param aclspec [String] The ACL specification included in ACL modification
    # operations in the format '[default:]user|group|other::r|-w|-x|-'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def modify_acl_entries_async(account_name, modify_acl_file_path, aclspec, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'modify_acl_file_path is nil' if modify_acl_file_path.nil?
      fail ArgumentError, 'aclspec is nil' if aclspec.nil?
      op = 'MODIFYACLENTRIES'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{modifyAclFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'modifyAclFilePath' => modify_acl_file_path},
          query_params: {'aclspec' => aclspec,'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :put, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Removes existing Access Control List (ACL) entries for a file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param remove_acl_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory with the ACL being removed.
    # @param aclspec [String] The ACL spec included in ACL removal operations in
    # the format '[default:]user|group|other'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def remove_acl_entries(account_name, remove_acl_file_path, aclspec, custom_headers = nil)
      response = remove_acl_entries_async(account_name, remove_acl_file_path, aclspec, custom_headers).value!
      nil
    end

    #
    # Removes existing Access Control List (ACL) entries for a file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param remove_acl_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory with the ACL being removed.
    # @param aclspec [String] The ACL spec included in ACL removal operations in
    # the format '[default:]user|group|other'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def remove_acl_entries_with_http_info(account_name, remove_acl_file_path, aclspec, custom_headers = nil)
      remove_acl_entries_async(account_name, remove_acl_file_path, aclspec, custom_headers).value!
    end

    #
    # Removes existing Access Control List (ACL) entries for a file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param remove_acl_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory with the ACL being removed.
    # @param aclspec [String] The ACL spec included in ACL removal operations in
    # the format '[default:]user|group|other'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def remove_acl_entries_async(account_name, remove_acl_file_path, aclspec, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'remove_acl_file_path is nil' if remove_acl_file_path.nil?
      fail ArgumentError, 'aclspec is nil' if aclspec.nil?
      op = 'REMOVEACLENTRIES'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{removeAclFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'removeAclFilePath' => remove_acl_file_path},
          query_params: {'aclspec' => aclspec,'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :put, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Gets Access Control List (ACL) entries for the specified file or directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param acl_file_path [String] The Data Lake Store path (starting with '/')
    # of the file or directory for which to get the ACL.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [AclStatusResult] operation results.
    #
    def get_acl_status(account_name, acl_file_path, custom_headers = nil)
      response = get_acl_status_async(account_name, acl_file_path, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets Access Control List (ACL) entries for the specified file or directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param acl_file_path [String] The Data Lake Store path (starting with '/')
    # of the file or directory for which to get the ACL.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_acl_status_with_http_info(account_name, acl_file_path, custom_headers = nil)
      get_acl_status_async(account_name, acl_file_path, custom_headers).value!
    end

    #
    # Gets Access Control List (ACL) entries for the specified file or directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param acl_file_path [String] The Data Lake Store path (starting with '/')
    # of the file or directory for which to get the ACL.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_acl_status_async(account_name, acl_file_path, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'acl_file_path is nil' if acl_file_path.nil?
      op = 'GETACLSTATUS'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{aclFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'aclFilePath' => acl_file_path},
          query_params: {'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :get, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = AclStatusResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response, 'result.body')
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Deletes the requested file or directory, optionally recursively.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param file_path [String] The Data Lake Store path (starting with '/') of
    # the file or directory to delete.
    # @param recursive [Boolean] The optional switch indicating if the delete
    # should be recursive
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FileOperationResult] operation results.
    #
    def delete(account_name, file_path, recursive = nil, custom_headers = nil)
      response = delete_async(account_name, file_path, recursive, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes the requested file or directory, optionally recursively.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param file_path [String] The Data Lake Store path (starting with '/') of
    # the file or directory to delete.
    # @param recursive [Boolean] The optional switch indicating if the delete
    # should be recursive
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_with_http_info(account_name, file_path, recursive = nil, custom_headers = nil)
      delete_async(account_name, file_path, recursive, custom_headers).value!
    end

    #
    # Deletes the requested file or directory, optionally recursively.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param file_path [String] The Data Lake Store path (starting with '/') of
    # the file or directory to delete.
    # @param recursive [Boolean] The optional switch indicating if the delete
    # should be recursive
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_async(account_name, file_path, recursive = nil, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'file_path is nil' if file_path.nil?
      op = 'DELETE'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{filePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'filePath' => file_path},
          query_params: {'recursive' => recursive,'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :delete, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = FileOperationResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response, 'result.body')
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Rename a file or directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param rename_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory to move/rename.
    # @param destination [String] The path to move/rename the file or folder to
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FileOperationResult] operation results.
    #
    def rename(account_name, rename_file_path, destination, custom_headers = nil)
      response = rename_async(account_name, rename_file_path, destination, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Rename a file or directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param rename_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory to move/rename.
    # @param destination [String] The path to move/rename the file or folder to
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def rename_with_http_info(account_name, rename_file_path, destination, custom_headers = nil)
      rename_async(account_name, rename_file_path, destination, custom_headers).value!
    end

    #
    # Rename a file or directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param rename_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory to move/rename.
    # @param destination [String] The path to move/rename the file or folder to
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def rename_async(account_name, rename_file_path, destination, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'rename_file_path is nil' if rename_file_path.nil?
      fail ArgumentError, 'destination is nil' if destination.nil?
      op = 'RENAME'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{renameFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'renameFilePath' => rename_file_path},
          query_params: {'destination' => destination,'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :put, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = FileOperationResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response, 'result.body')
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Sets the owner of a file or directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param set_owner_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory for which to set the owner.
    # @param owner [String] The AAD Object ID of the user owner of the file or
    # directory. If empty, the property will remain unchanged.
    # @param group [String] The AAD Object ID of the group owner of the file or
    # directory. If empty, the property will remain unchanged.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def set_owner(account_name, set_owner_file_path, owner = nil, group = nil, custom_headers = nil)
      response = set_owner_async(account_name, set_owner_file_path, owner, group, custom_headers).value!
      nil
    end

    #
    # Sets the owner of a file or directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param set_owner_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory for which to set the owner.
    # @param owner [String] The AAD Object ID of the user owner of the file or
    # directory. If empty, the property will remain unchanged.
    # @param group [String] The AAD Object ID of the group owner of the file or
    # directory. If empty, the property will remain unchanged.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def set_owner_with_http_info(account_name, set_owner_file_path, owner = nil, group = nil, custom_headers = nil)
      set_owner_async(account_name, set_owner_file_path, owner, group, custom_headers).value!
    end

    #
    # Sets the owner of a file or directory.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param set_owner_file_path [String] The Data Lake Store path (starting with
    # '/') of the file or directory for which to set the owner.
    # @param owner [String] The AAD Object ID of the user owner of the file or
    # directory. If empty, the property will remain unchanged.
    # @param group [String] The AAD Object ID of the group owner of the file or
    # directory. If empty, the property will remain unchanged.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def set_owner_async(account_name, set_owner_file_path, owner = nil, group = nil, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'set_owner_file_path is nil' if set_owner_file_path.nil?
      op = 'SETOWNER'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{setOwnerFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'setOwnerFilePath' => set_owner_file_path},
          query_params: {'owner' => owner,'group' => group,'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :put, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Sets the permission of the file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param set_permission_file_path [String] The Data Lake Store path (starting
    # with '/') of the file or directory for which to set the permission.
    # @param permission [String] A string representation of the permission (i.e
    # 'rwx'). If empty, this property remains unchanged.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def set_permission(account_name, set_permission_file_path, permission = nil, custom_headers = nil)
      response = set_permission_async(account_name, set_permission_file_path, permission, custom_headers).value!
      nil
    end

    #
    # Sets the permission of the file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param set_permission_file_path [String] The Data Lake Store path (starting
    # with '/') of the file or directory for which to set the permission.
    # @param permission [String] A string representation of the permission (i.e
    # 'rwx'). If empty, this property remains unchanged.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def set_permission_with_http_info(account_name, set_permission_file_path, permission = nil, custom_headers = nil)
      set_permission_async(account_name, set_permission_file_path, permission, custom_headers).value!
    end

    #
    # Sets the permission of the file or folder.
    #
    # @param account_name [String] The Azure Data Lake Store account to execute
    # filesystem operations on.
    # @param set_permission_file_path [String] The Data Lake Store path (starting
    # with '/') of the file or directory for which to set the permission.
    # @param permission [String] A string representation of the permission (i.e
    # 'rwx'). If empty, this property remains unchanged.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def set_permission_async(account_name, set_permission_file_path, permission = nil, custom_headers = nil)
      fail ArgumentError, 'account_name is nil' if account_name.nil?
      fail ArgumentError, '@client.adls_file_system_dns_suffix is nil' if @client.adls_file_system_dns_suffix.nil?
      fail ArgumentError, 'set_permission_file_path is nil' if set_permission_file_path.nil?
      op = 'SETPERMISSION'
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = '/webhdfs/v1/{setPermissionFilePath}'
      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'setPermissionFilePath' => set_permission_file_path},
          query_params: {'permission' => permission,'op' => op,'api-version' => @client.api_version},
          headers: request_headers.merge(custom_headers || {})
      }

      request_url = @base_url || @client.base_url
      request_url = request_url.gsub('{accountName}', account_name)
      request_url = request_url.gsub('{adlsFileSystemDnsSuffix}', @client.adls_file_system_dns_suffix)

      request = MsRest::HttpOperationRequest.new(request_url, path_template, :put, options)
      promise = request.run_promise do |req|
        @client.credentials.sign_request(req) unless @client.credentials.nil?
      end

      promise = promise.then do |http_response|
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(request, http_response, error_model)
        end

        # Create Result
        result = MsRestAzure::AzureOperationResponse.new(request, http_response)
        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

  end
end
