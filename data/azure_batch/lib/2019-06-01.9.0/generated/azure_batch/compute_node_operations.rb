# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Azure::Batch::V2019_06_01_9_0
  #
  # A client for issuing REST requests to the Azure Batch service.
  #
  class ComputeNodeOperations
    include MsRestAzure

    #
    # Creates and initializes a new instance of the ComputeNodeOperations class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
      @client = client
    end

    # @return [BatchServiceClient] reference to the BatchServiceClient
    attr_reader :client

    #
    # Adds a user Account to the specified Compute Node.
    #
    # You can add a user Account to a Compute Node only when it is in the idle or
    # running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the machine on which you want to create a
    # user Account.
    # @param user [ComputeNodeUser] The user Account to be created.
    # @param compute_node_add_user_options [ComputeNodeAddUserOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def add_user(pool_id, node_id, user, compute_node_add_user_options:nil, custom_headers:nil)
      response = add_user_async(pool_id, node_id, user, compute_node_add_user_options:compute_node_add_user_options, custom_headers:custom_headers).value!
      nil
    end

    #
    # Adds a user Account to the specified Compute Node.
    #
    # You can add a user Account to a Compute Node only when it is in the idle or
    # running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the machine on which you want to create a
    # user Account.
    # @param user [ComputeNodeUser] The user Account to be created.
    # @param compute_node_add_user_options [ComputeNodeAddUserOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def add_user_with_http_info(pool_id, node_id, user, compute_node_add_user_options:nil, custom_headers:nil)
      add_user_async(pool_id, node_id, user, compute_node_add_user_options:compute_node_add_user_options, custom_headers:custom_headers).value!
    end

    #
    # Adds a user Account to the specified Compute Node.
    #
    # You can add a user Account to a Compute Node only when it is in the idle or
    # running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the machine on which you want to create a
    # user Account.
    # @param user [ComputeNodeUser] The user Account to be created.
    # @param compute_node_add_user_options [ComputeNodeAddUserOptions] Additional
    # parameters for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def add_user_async(pool_id, node_id, user, compute_node_add_user_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, 'user is nil' if user.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_add_user_options.nil?
        timeout = compute_node_add_user_options.timeout
      end
      unless compute_node_add_user_options.nil?
        client_request_id = compute_node_add_user_options.client_request_id
      end
      unless compute_node_add_user_options.nil?
        return_client_request_id = compute_node_add_user_options.return_client_request_id
      end
      unless compute_node_add_user_options.nil?
        ocp_date = compute_node_add_user_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?

      # Serialize Request
      request_mapper = Azure::Batch::V2019_06_01_9_0::Models::ComputeNodeUser.mapper()
      request_content = @client.serialize(request_mapper,  user)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'pools/{poolId}/nodes/{nodeId}/users'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id},
          query_params: {'api-version' => @client.api_version,'timeout' => timeout},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Deletes a user Account from the specified Compute Node.
    #
    # You can delete a user Account to a Compute Node only when it is in the idle
    # or running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the machine on which you want to delete a
    # user Account.
    # @param user_name [String] The name of the user Account to delete.
    # @param compute_node_delete_user_options [ComputeNodeDeleteUserOptions]
    # Additional parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_user(pool_id, node_id, user_name, compute_node_delete_user_options:nil, custom_headers:nil)
      response = delete_user_async(pool_id, node_id, user_name, compute_node_delete_user_options:compute_node_delete_user_options, custom_headers:custom_headers).value!
      nil
    end

    #
    # Deletes a user Account from the specified Compute Node.
    #
    # You can delete a user Account to a Compute Node only when it is in the idle
    # or running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the machine on which you want to delete a
    # user Account.
    # @param user_name [String] The name of the user Account to delete.
    # @param compute_node_delete_user_options [ComputeNodeDeleteUserOptions]
    # Additional parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_user_with_http_info(pool_id, node_id, user_name, compute_node_delete_user_options:nil, custom_headers:nil)
      delete_user_async(pool_id, node_id, user_name, compute_node_delete_user_options:compute_node_delete_user_options, custom_headers:custom_headers).value!
    end

    #
    # Deletes a user Account from the specified Compute Node.
    #
    # You can delete a user Account to a Compute Node only when it is in the idle
    # or running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the machine on which you want to delete a
    # user Account.
    # @param user_name [String] The name of the user Account to delete.
    # @param compute_node_delete_user_options [ComputeNodeDeleteUserOptions]
    # Additional parameters for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_user_async(pool_id, node_id, user_name, compute_node_delete_user_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, 'user_name is nil' if user_name.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_delete_user_options.nil?
        timeout = compute_node_delete_user_options.timeout
      end
      unless compute_node_delete_user_options.nil?
        client_request_id = compute_node_delete_user_options.client_request_id
      end
      unless compute_node_delete_user_options.nil?
        return_client_request_id = compute_node_delete_user_options.return_client_request_id
      end
      unless compute_node_delete_user_options.nil?
        ocp_date = compute_node_delete_user_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?
      path_template = 'pools/{poolId}/nodes/{nodeId}/users/{userName}'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id,'userName' => user_name},
          query_params: {'api-version' => @client.api_version,'timeout' => timeout},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Updates the password and expiration time of a user Account on the specified
    # Compute Node.
    #
    # This operation replaces of all the updatable properties of the Account. For
    # example, if the expiryTime element is not specified, the current value is
    # replaced with the default value, not left unmodified. You can update a user
    # Account on a Compute Node only when it is in the idle or running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the machine on which you want to update a
    # user Account.
    # @param user_name [String] The name of the user Account to update.
    # @param node_update_user_parameter [NodeUpdateUserParameter] The parameters
    # for the request.
    # @param compute_node_update_user_options [ComputeNodeUpdateUserOptions]
    # Additional parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def update_user(pool_id, node_id, user_name, node_update_user_parameter, compute_node_update_user_options:nil, custom_headers:nil)
      response = update_user_async(pool_id, node_id, user_name, node_update_user_parameter, compute_node_update_user_options:compute_node_update_user_options, custom_headers:custom_headers).value!
      nil
    end

    #
    # Updates the password and expiration time of a user Account on the specified
    # Compute Node.
    #
    # This operation replaces of all the updatable properties of the Account. For
    # example, if the expiryTime element is not specified, the current value is
    # replaced with the default value, not left unmodified. You can update a user
    # Account on a Compute Node only when it is in the idle or running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the machine on which you want to update a
    # user Account.
    # @param user_name [String] The name of the user Account to update.
    # @param node_update_user_parameter [NodeUpdateUserParameter] The parameters
    # for the request.
    # @param compute_node_update_user_options [ComputeNodeUpdateUserOptions]
    # Additional parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def update_user_with_http_info(pool_id, node_id, user_name, node_update_user_parameter, compute_node_update_user_options:nil, custom_headers:nil)
      update_user_async(pool_id, node_id, user_name, node_update_user_parameter, compute_node_update_user_options:compute_node_update_user_options, custom_headers:custom_headers).value!
    end

    #
    # Updates the password and expiration time of a user Account on the specified
    # Compute Node.
    #
    # This operation replaces of all the updatable properties of the Account. For
    # example, if the expiryTime element is not specified, the current value is
    # replaced with the default value, not left unmodified. You can update a user
    # Account on a Compute Node only when it is in the idle or running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the machine on which you want to update a
    # user Account.
    # @param user_name [String] The name of the user Account to update.
    # @param node_update_user_parameter [NodeUpdateUserParameter] The parameters
    # for the request.
    # @param compute_node_update_user_options [ComputeNodeUpdateUserOptions]
    # Additional parameters for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_user_async(pool_id, node_id, user_name, node_update_user_parameter, compute_node_update_user_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, 'user_name is nil' if user_name.nil?
      fail ArgumentError, 'node_update_user_parameter is nil' if node_update_user_parameter.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_update_user_options.nil?
        timeout = compute_node_update_user_options.timeout
      end
      unless compute_node_update_user_options.nil?
        client_request_id = compute_node_update_user_options.client_request_id
      end
      unless compute_node_update_user_options.nil?
        return_client_request_id = compute_node_update_user_options.return_client_request_id
      end
      unless compute_node_update_user_options.nil?
        ocp_date = compute_node_update_user_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?

      # Serialize Request
      request_mapper = Azure::Batch::V2019_06_01_9_0::Models::NodeUpdateUserParameter.mapper()
      request_content = @client.serialize(request_mapper,  node_update_user_parameter)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'pools/{poolId}/nodes/{nodeId}/users/{userName}'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id,'userName' => user_name},
          query_params: {'api-version' => @client.api_version,'timeout' => timeout},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Gets information about the specified Compute Node.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node that you want to get
    # information about.
    # @param compute_node_get_options [ComputeNodeGetOptions] Additional parameters
    # for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ComputeNode] operation results.
    #
    def get(pool_id, node_id, compute_node_get_options:nil, custom_headers:nil)
      response = get_async(pool_id, node_id, compute_node_get_options:compute_node_get_options, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets information about the specified Compute Node.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node that you want to get
    # information about.
    # @param compute_node_get_options [ComputeNodeGetOptions] Additional parameters
    # for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_with_http_info(pool_id, node_id, compute_node_get_options:nil, custom_headers:nil)
      get_async(pool_id, node_id, compute_node_get_options:compute_node_get_options, custom_headers:custom_headers).value!
    end

    #
    # Gets information about the specified Compute Node.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node that you want to get
    # information about.
    # @param compute_node_get_options [ComputeNodeGetOptions] Additional parameters
    # for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_async(pool_id, node_id, compute_node_get_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      select = nil
      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_get_options.nil?
        select = compute_node_get_options.select
      end
      unless compute_node_get_options.nil?
        timeout = compute_node_get_options.timeout
      end
      unless compute_node_get_options.nil?
        client_request_id = compute_node_get_options.client_request_id
      end
      unless compute_node_get_options.nil?
        return_client_request_id = compute_node_get_options.return_client_request_id
      end
      unless compute_node_get_options.nil?
        ocp_date = compute_node_get_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?
      path_template = 'pools/{poolId}/nodes/{nodeId}'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id},
          query_params: {'api-version' => @client.api_version,'$select' => select,'timeout' => timeout},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::Batch::V2019_06_01_9_0::Models::ComputeNode.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Restarts the specified Compute Node.
    #
    # You can restart a Compute Node only if it is in an idle or running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node that you want to restart.
    # @param node_reboot_parameter [NodeRebootParameter] The parameters for the
    # request.
    # @param compute_node_reboot_options [ComputeNodeRebootOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def reboot(pool_id, node_id, node_reboot_parameter:nil, compute_node_reboot_options:nil, custom_headers:nil)
      response = reboot_async(pool_id, node_id, node_reboot_parameter:node_reboot_parameter, compute_node_reboot_options:compute_node_reboot_options, custom_headers:custom_headers).value!
      nil
    end

    #
    # Restarts the specified Compute Node.
    #
    # You can restart a Compute Node only if it is in an idle or running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node that you want to restart.
    # @param node_reboot_parameter [NodeRebootParameter] The parameters for the
    # request.
    # @param compute_node_reboot_options [ComputeNodeRebootOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def reboot_with_http_info(pool_id, node_id, node_reboot_parameter:nil, compute_node_reboot_options:nil, custom_headers:nil)
      reboot_async(pool_id, node_id, node_reboot_parameter:node_reboot_parameter, compute_node_reboot_options:compute_node_reboot_options, custom_headers:custom_headers).value!
    end

    #
    # Restarts the specified Compute Node.
    #
    # You can restart a Compute Node only if it is in an idle or running state.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node that you want to restart.
    # @param node_reboot_parameter [NodeRebootParameter] The parameters for the
    # request.
    # @param compute_node_reboot_options [ComputeNodeRebootOptions] Additional
    # parameters for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def reboot_async(pool_id, node_id, node_reboot_parameter:nil, compute_node_reboot_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_reboot_options.nil?
        timeout = compute_node_reboot_options.timeout
      end
      unless compute_node_reboot_options.nil?
        client_request_id = compute_node_reboot_options.client_request_id
      end
      unless compute_node_reboot_options.nil?
        return_client_request_id = compute_node_reboot_options.return_client_request_id
      end
      unless compute_node_reboot_options.nil?
        ocp_date = compute_node_reboot_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?

      # Serialize Request
      request_mapper = Azure::Batch::V2019_06_01_9_0::Models::NodeRebootParameter.mapper()
      request_content = @client.serialize(request_mapper,  node_reboot_parameter)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'pools/{poolId}/nodes/{nodeId}/reboot'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id},
          query_params: {'api-version' => @client.api_version,'timeout' => timeout},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 202
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Reinstalls the operating system on the specified Compute Node.
    #
    # You can reinstall the operating system on a Compute Node only if it is in an
    # idle or running state. This API can be invoked only on Pools created with the
    # cloud service configuration property.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node that you want to restart.
    # @param node_reimage_parameter [NodeReimageParameter] The parameters for the
    # request.
    # @param compute_node_reimage_options [ComputeNodeReimageOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def reimage(pool_id, node_id, node_reimage_parameter:nil, compute_node_reimage_options:nil, custom_headers:nil)
      response = reimage_async(pool_id, node_id, node_reimage_parameter:node_reimage_parameter, compute_node_reimage_options:compute_node_reimage_options, custom_headers:custom_headers).value!
      nil
    end

    #
    # Reinstalls the operating system on the specified Compute Node.
    #
    # You can reinstall the operating system on a Compute Node only if it is in an
    # idle or running state. This API can be invoked only on Pools created with the
    # cloud service configuration property.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node that you want to restart.
    # @param node_reimage_parameter [NodeReimageParameter] The parameters for the
    # request.
    # @param compute_node_reimage_options [ComputeNodeReimageOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def reimage_with_http_info(pool_id, node_id, node_reimage_parameter:nil, compute_node_reimage_options:nil, custom_headers:nil)
      reimage_async(pool_id, node_id, node_reimage_parameter:node_reimage_parameter, compute_node_reimage_options:compute_node_reimage_options, custom_headers:custom_headers).value!
    end

    #
    # Reinstalls the operating system on the specified Compute Node.
    #
    # You can reinstall the operating system on a Compute Node only if it is in an
    # idle or running state. This API can be invoked only on Pools created with the
    # cloud service configuration property.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node that you want to restart.
    # @param node_reimage_parameter [NodeReimageParameter] The parameters for the
    # request.
    # @param compute_node_reimage_options [ComputeNodeReimageOptions] Additional
    # parameters for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def reimage_async(pool_id, node_id, node_reimage_parameter:nil, compute_node_reimage_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_reimage_options.nil?
        timeout = compute_node_reimage_options.timeout
      end
      unless compute_node_reimage_options.nil?
        client_request_id = compute_node_reimage_options.client_request_id
      end
      unless compute_node_reimage_options.nil?
        return_client_request_id = compute_node_reimage_options.return_client_request_id
      end
      unless compute_node_reimage_options.nil?
        ocp_date = compute_node_reimage_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?

      # Serialize Request
      request_mapper = Azure::Batch::V2019_06_01_9_0::Models::NodeReimageParameter.mapper()
      request_content = @client.serialize(request_mapper,  node_reimage_parameter)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'pools/{poolId}/nodes/{nodeId}/reimage'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id},
          query_params: {'api-version' => @client.api_version,'timeout' => timeout},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 202
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Disables Task scheduling on the specified Compute Node.
    #
    # You can disable Task scheduling on a Compute Node only if its current
    # scheduling state is enabled.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node on which you want to
    # disable Task scheduling.
    # @param node_disable_scheduling_parameter [NodeDisableSchedulingParameter] The
    # parameters for the request.
    # @param compute_node_disable_scheduling_options
    # [ComputeNodeDisableSchedulingOptions] Additional parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def disable_scheduling(pool_id, node_id, node_disable_scheduling_parameter:nil, compute_node_disable_scheduling_options:nil, custom_headers:nil)
      response = disable_scheduling_async(pool_id, node_id, node_disable_scheduling_parameter:node_disable_scheduling_parameter, compute_node_disable_scheduling_options:compute_node_disable_scheduling_options, custom_headers:custom_headers).value!
      nil
    end

    #
    # Disables Task scheduling on the specified Compute Node.
    #
    # You can disable Task scheduling on a Compute Node only if its current
    # scheduling state is enabled.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node on which you want to
    # disable Task scheduling.
    # @param node_disable_scheduling_parameter [NodeDisableSchedulingParameter] The
    # parameters for the request.
    # @param compute_node_disable_scheduling_options
    # [ComputeNodeDisableSchedulingOptions] Additional parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def disable_scheduling_with_http_info(pool_id, node_id, node_disable_scheduling_parameter:nil, compute_node_disable_scheduling_options:nil, custom_headers:nil)
      disable_scheduling_async(pool_id, node_id, node_disable_scheduling_parameter:node_disable_scheduling_parameter, compute_node_disable_scheduling_options:compute_node_disable_scheduling_options, custom_headers:custom_headers).value!
    end

    #
    # Disables Task scheduling on the specified Compute Node.
    #
    # You can disable Task scheduling on a Compute Node only if its current
    # scheduling state is enabled.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node on which you want to
    # disable Task scheduling.
    # @param node_disable_scheduling_parameter [NodeDisableSchedulingParameter] The
    # parameters for the request.
    # @param compute_node_disable_scheduling_options
    # [ComputeNodeDisableSchedulingOptions] Additional parameters for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def disable_scheduling_async(pool_id, node_id, node_disable_scheduling_parameter:nil, compute_node_disable_scheduling_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_disable_scheduling_options.nil?
        timeout = compute_node_disable_scheduling_options.timeout
      end
      unless compute_node_disable_scheduling_options.nil?
        client_request_id = compute_node_disable_scheduling_options.client_request_id
      end
      unless compute_node_disable_scheduling_options.nil?
        return_client_request_id = compute_node_disable_scheduling_options.return_client_request_id
      end
      unless compute_node_disable_scheduling_options.nil?
        ocp_date = compute_node_disable_scheduling_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?

      # Serialize Request
      request_mapper = Azure::Batch::V2019_06_01_9_0::Models::NodeDisableSchedulingParameter.mapper()
      request_content = @client.serialize(request_mapper,  node_disable_scheduling_parameter)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'pools/{poolId}/nodes/{nodeId}/disablescheduling'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id},
          query_params: {'api-version' => @client.api_version,'timeout' => timeout},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Enables Task scheduling on the specified Compute Node.
    #
    # You can enable Task scheduling on a Compute Node only if its current
    # scheduling state is disabled
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node on which you want to
    # enable Task scheduling.
    # @param compute_node_enable_scheduling_options
    # [ComputeNodeEnableSchedulingOptions] Additional parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def enable_scheduling(pool_id, node_id, compute_node_enable_scheduling_options:nil, custom_headers:nil)
      response = enable_scheduling_async(pool_id, node_id, compute_node_enable_scheduling_options:compute_node_enable_scheduling_options, custom_headers:custom_headers).value!
      nil
    end

    #
    # Enables Task scheduling on the specified Compute Node.
    #
    # You can enable Task scheduling on a Compute Node only if its current
    # scheduling state is disabled
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node on which you want to
    # enable Task scheduling.
    # @param compute_node_enable_scheduling_options
    # [ComputeNodeEnableSchedulingOptions] Additional parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def enable_scheduling_with_http_info(pool_id, node_id, compute_node_enable_scheduling_options:nil, custom_headers:nil)
      enable_scheduling_async(pool_id, node_id, compute_node_enable_scheduling_options:compute_node_enable_scheduling_options, custom_headers:custom_headers).value!
    end

    #
    # Enables Task scheduling on the specified Compute Node.
    #
    # You can enable Task scheduling on a Compute Node only if its current
    # scheduling state is disabled
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node on which you want to
    # enable Task scheduling.
    # @param compute_node_enable_scheduling_options
    # [ComputeNodeEnableSchedulingOptions] Additional parameters for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def enable_scheduling_async(pool_id, node_id, compute_node_enable_scheduling_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_enable_scheduling_options.nil?
        timeout = compute_node_enable_scheduling_options.timeout
      end
      unless compute_node_enable_scheduling_options.nil?
        client_request_id = compute_node_enable_scheduling_options.client_request_id
      end
      unless compute_node_enable_scheduling_options.nil?
        return_client_request_id = compute_node_enable_scheduling_options.return_client_request_id
      end
      unless compute_node_enable_scheduling_options.nil?
        ocp_date = compute_node_enable_scheduling_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?
      path_template = 'pools/{poolId}/nodes/{nodeId}/enablescheduling'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id},
          query_params: {'api-version' => @client.api_version,'timeout' => timeout},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Gets the settings required for remote login to a Compute Node.
    #
    # Before you can remotely login to a Compute Node using the remote login
    # settings, you must create a user Account on the Compute Node. This API can be
    # invoked only on Pools created with the virtual machine configuration
    # property. For Pools created with a cloud service configuration, see the
    # GetRemoteDesktop API.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node for which to obtain the
    # remote login settings.
    # @param compute_node_get_remote_login_settings_options
    # [ComputeNodeGetRemoteLoginSettingsOptions] Additional parameters for the
    # operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ComputeNodeGetRemoteLoginSettingsResult] operation results.
    #
    def get_remote_login_settings(pool_id, node_id, compute_node_get_remote_login_settings_options:nil, custom_headers:nil)
      response = get_remote_login_settings_async(pool_id, node_id, compute_node_get_remote_login_settings_options:compute_node_get_remote_login_settings_options, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets the settings required for remote login to a Compute Node.
    #
    # Before you can remotely login to a Compute Node using the remote login
    # settings, you must create a user Account on the Compute Node. This API can be
    # invoked only on Pools created with the virtual machine configuration
    # property. For Pools created with a cloud service configuration, see the
    # GetRemoteDesktop API.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node for which to obtain the
    # remote login settings.
    # @param compute_node_get_remote_login_settings_options
    # [ComputeNodeGetRemoteLoginSettingsOptions] Additional parameters for the
    # operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_remote_login_settings_with_http_info(pool_id, node_id, compute_node_get_remote_login_settings_options:nil, custom_headers:nil)
      get_remote_login_settings_async(pool_id, node_id, compute_node_get_remote_login_settings_options:compute_node_get_remote_login_settings_options, custom_headers:custom_headers).value!
    end

    #
    # Gets the settings required for remote login to a Compute Node.
    #
    # Before you can remotely login to a Compute Node using the remote login
    # settings, you must create a user Account on the Compute Node. This API can be
    # invoked only on Pools created with the virtual machine configuration
    # property. For Pools created with a cloud service configuration, see the
    # GetRemoteDesktop API.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node for which to obtain the
    # remote login settings.
    # @param compute_node_get_remote_login_settings_options
    # [ComputeNodeGetRemoteLoginSettingsOptions] Additional parameters for the
    # operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_remote_login_settings_async(pool_id, node_id, compute_node_get_remote_login_settings_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_get_remote_login_settings_options.nil?
        timeout = compute_node_get_remote_login_settings_options.timeout
      end
      unless compute_node_get_remote_login_settings_options.nil?
        client_request_id = compute_node_get_remote_login_settings_options.client_request_id
      end
      unless compute_node_get_remote_login_settings_options.nil?
        return_client_request_id = compute_node_get_remote_login_settings_options.return_client_request_id
      end
      unless compute_node_get_remote_login_settings_options.nil?
        ocp_date = compute_node_get_remote_login_settings_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?
      path_template = 'pools/{poolId}/nodes/{nodeId}/remoteloginsettings'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id},
          query_params: {'api-version' => @client.api_version,'timeout' => timeout},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::Batch::V2019_06_01_9_0::Models::ComputeNodeGetRemoteLoginSettingsResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets the Remote Desktop Protocol file for the specified Compute Node.
    #
    # Before you can access a Compute Node by using the RDP file, you must create a
    # user Account on the Compute Node. This API can only be invoked on Pools
    # created with a cloud service configuration. For Pools created with a virtual
    # machine configuration, see the GetRemoteLoginSettings API.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node for which you want to get
    # the Remote Desktop Protocol file.
    # @param compute_node_get_remote_desktop_options
    # [ComputeNodeGetRemoteDesktopOptions] Additional parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [NOT_IMPLEMENTED] operation results.
    #
    def get_remote_desktop(pool_id, node_id, compute_node_get_remote_desktop_options:nil, custom_headers:nil)
      response = get_remote_desktop_async(pool_id, node_id, compute_node_get_remote_desktop_options:compute_node_get_remote_desktop_options, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets the Remote Desktop Protocol file for the specified Compute Node.
    #
    # Before you can access a Compute Node by using the RDP file, you must create a
    # user Account on the Compute Node. This API can only be invoked on Pools
    # created with a cloud service configuration. For Pools created with a virtual
    # machine configuration, see the GetRemoteLoginSettings API.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node for which you want to get
    # the Remote Desktop Protocol file.
    # @param compute_node_get_remote_desktop_options
    # [ComputeNodeGetRemoteDesktopOptions] Additional parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_remote_desktop_with_http_info(pool_id, node_id, compute_node_get_remote_desktop_options:nil, custom_headers:nil)
      get_remote_desktop_async(pool_id, node_id, compute_node_get_remote_desktop_options:compute_node_get_remote_desktop_options, custom_headers:custom_headers).value!
    end

    #
    # Gets the Remote Desktop Protocol file for the specified Compute Node.
    #
    # Before you can access a Compute Node by using the RDP file, you must create a
    # user Account on the Compute Node. This API can only be invoked on Pools
    # created with a cloud service configuration. For Pools created with a virtual
    # machine configuration, see the GetRemoteLoginSettings API.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node for which you want to get
    # the Remote Desktop Protocol file.
    # @param compute_node_get_remote_desktop_options
    # [ComputeNodeGetRemoteDesktopOptions] Additional parameters for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_remote_desktop_async(pool_id, node_id, compute_node_get_remote_desktop_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_get_remote_desktop_options.nil?
        timeout = compute_node_get_remote_desktop_options.timeout
      end
      unless compute_node_get_remote_desktop_options.nil?
        client_request_id = compute_node_get_remote_desktop_options.client_request_id
      end
      unless compute_node_get_remote_desktop_options.nil?
        return_client_request_id = compute_node_get_remote_desktop_options.return_client_request_id
      end
      unless compute_node_get_remote_desktop_options.nil?
        ocp_date = compute_node_get_remote_desktop_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?
      path_template = 'pools/{poolId}/nodes/{nodeId}/rdp'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id},
          query_params: {'api-version' => @client.api_version,'timeout' => timeout},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Stream'
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Upload Azure Batch service log files from the specified Compute Node to Azure
    # Blob Storage.
    #
    # This is for gathering Azure Batch service log files in an automated fashion
    # from Compute Nodes if you are experiencing an error and wish to escalate to
    # Azure support. The Azure Batch service log files should be shared with Azure
    # support to aid in debugging issues with the Batch service.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node from which you want to
    # upload the Azure Batch service log files.
    # @param upload_batch_service_logs_configuration
    # [UploadBatchServiceLogsConfiguration] The Azure Batch service log files
    # upload configuration.
    # @param compute_node_upload_batch_service_logs_options
    # [ComputeNodeUploadBatchServiceLogsOptions] Additional parameters for the
    # operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [UploadBatchServiceLogsResult] operation results.
    #
    def upload_batch_service_logs(pool_id, node_id, upload_batch_service_logs_configuration, compute_node_upload_batch_service_logs_options:nil, custom_headers:nil)
      response = upload_batch_service_logs_async(pool_id, node_id, upload_batch_service_logs_configuration, compute_node_upload_batch_service_logs_options:compute_node_upload_batch_service_logs_options, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Upload Azure Batch service log files from the specified Compute Node to Azure
    # Blob Storage.
    #
    # This is for gathering Azure Batch service log files in an automated fashion
    # from Compute Nodes if you are experiencing an error and wish to escalate to
    # Azure support. The Azure Batch service log files should be shared with Azure
    # support to aid in debugging issues with the Batch service.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node from which you want to
    # upload the Azure Batch service log files.
    # @param upload_batch_service_logs_configuration
    # [UploadBatchServiceLogsConfiguration] The Azure Batch service log files
    # upload configuration.
    # @param compute_node_upload_batch_service_logs_options
    # [ComputeNodeUploadBatchServiceLogsOptions] Additional parameters for the
    # operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def upload_batch_service_logs_with_http_info(pool_id, node_id, upload_batch_service_logs_configuration, compute_node_upload_batch_service_logs_options:nil, custom_headers:nil)
      upload_batch_service_logs_async(pool_id, node_id, upload_batch_service_logs_configuration, compute_node_upload_batch_service_logs_options:compute_node_upload_batch_service_logs_options, custom_headers:custom_headers).value!
    end

    #
    # Upload Azure Batch service log files from the specified Compute Node to Azure
    # Blob Storage.
    #
    # This is for gathering Azure Batch service log files in an automated fashion
    # from Compute Nodes if you are experiencing an error and wish to escalate to
    # Azure support. The Azure Batch service log files should be shared with Azure
    # support to aid in debugging issues with the Batch service.
    #
    # @param pool_id [String] The ID of the Pool that contains the Compute Node.
    # @param node_id [String] The ID of the Compute Node from which you want to
    # upload the Azure Batch service log files.
    # @param upload_batch_service_logs_configuration
    # [UploadBatchServiceLogsConfiguration] The Azure Batch service log files
    # upload configuration.
    # @param compute_node_upload_batch_service_logs_options
    # [ComputeNodeUploadBatchServiceLogsOptions] Additional parameters for the
    # operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def upload_batch_service_logs_async(pool_id, node_id, upload_batch_service_logs_configuration, compute_node_upload_batch_service_logs_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, 'node_id is nil' if node_id.nil?
      fail ArgumentError, 'upload_batch_service_logs_configuration is nil' if upload_batch_service_logs_configuration.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_upload_batch_service_logs_options.nil?
        timeout = compute_node_upload_batch_service_logs_options.timeout
      end
      unless compute_node_upload_batch_service_logs_options.nil?
        client_request_id = compute_node_upload_batch_service_logs_options.client_request_id
      end
      unless compute_node_upload_batch_service_logs_options.nil?
        return_client_request_id = compute_node_upload_batch_service_logs_options.return_client_request_id
      end
      unless compute_node_upload_batch_service_logs_options.nil?
        ocp_date = compute_node_upload_batch_service_logs_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?

      # Serialize Request
      request_mapper = Azure::Batch::V2019_06_01_9_0::Models::UploadBatchServiceLogsConfiguration.mapper()
      request_content = @client.serialize(request_mapper,  upload_batch_service_logs_configuration)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'pools/{poolId}/nodes/{nodeId}/uploadbatchservicelogs'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id,'nodeId' => node_id},
          query_params: {'api-version' => @client.api_version,'timeout' => timeout},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::Batch::V2019_06_01_9_0::Models::UploadBatchServiceLogsResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the Compute Nodes in the specified Pool.
    #
    # @param pool_id [String] The ID of the Pool from which you want to list
    # Compute Nodes.
    # @param compute_node_list_options [ComputeNodeListOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<ComputeNode>] operation results.
    #
    def list(pool_id, compute_node_list_options:nil, custom_headers:nil)
      first_page = list_as_lazy(pool_id, compute_node_list_options:compute_node_list_options, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # Lists the Compute Nodes in the specified Pool.
    #
    # @param pool_id [String] The ID of the Pool from which you want to list
    # Compute Nodes.
    # @param compute_node_list_options [ComputeNodeListOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def list_with_http_info(pool_id, compute_node_list_options:nil, custom_headers:nil)
      list_async(pool_id, compute_node_list_options:compute_node_list_options, custom_headers:custom_headers).value!
    end

    #
    # Lists the Compute Nodes in the specified Pool.
    #
    # @param pool_id [String] The ID of the Pool from which you want to list
    # Compute Nodes.
    # @param compute_node_list_options [ComputeNodeListOptions] Additional
    # parameters for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_async(pool_id, compute_node_list_options:nil, custom_headers:nil)
      fail ArgumentError, '@client.batch_url is nil' if @client.batch_url.nil?
      fail ArgumentError, 'pool_id is nil' if pool_id.nil?
      fail ArgumentError, '@client.api_version is nil' if @client.api_version.nil?

      filter = nil
      select = nil
      max_results = nil
      timeout = nil
      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_list_options.nil?
        filter = compute_node_list_options.filter
      end
      unless compute_node_list_options.nil?
        select = compute_node_list_options.select
      end
      unless compute_node_list_options.nil?
        max_results = compute_node_list_options.maxResults
      end
      unless compute_node_list_options.nil?
        timeout = compute_node_list_options.timeout
      end
      unless compute_node_list_options.nil?
        client_request_id = compute_node_list_options.client_request_id
      end
      unless compute_node_list_options.nil?
        return_client_request_id = compute_node_list_options.return_client_request_id
      end
      unless compute_node_list_options.nil?
        ocp_date = compute_node_list_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?
      path_template = 'pools/{poolId}/nodes'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{batchUrl}', @client.batch_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'poolId' => pool_id},
          query_params: {'api-version' => @client.api_version,'$filter' => filter,'$select' => select,'maxresults' => max_results,'timeout' => timeout},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::Batch::V2019_06_01_9_0::Models::ComputeNodeListResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the Compute Nodes in the specified Pool.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param compute_node_list_next_options [ComputeNodeListNextOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ComputeNodeListResult] operation results.
    #
    def list_next(next_page_link, compute_node_list_next_options:nil, custom_headers:nil)
      response = list_next_async(next_page_link, compute_node_list_next_options:compute_node_list_next_options, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Lists the Compute Nodes in the specified Pool.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param compute_node_list_next_options [ComputeNodeListNextOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def list_next_with_http_info(next_page_link, compute_node_list_next_options:nil, custom_headers:nil)
      list_next_async(next_page_link, compute_node_list_next_options:compute_node_list_next_options, custom_headers:custom_headers).value!
    end

    #
    # Lists the Compute Nodes in the specified Pool.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param compute_node_list_next_options [ComputeNodeListNextOptions] Additional
    # parameters for the operation
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_next_async(next_page_link, compute_node_list_next_options:nil, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?

      client_request_id = nil
      return_client_request_id = nil
      ocp_date = nil
      unless compute_node_list_next_options.nil?
        client_request_id = compute_node_list_next_options.client_request_id
      end
      unless compute_node_list_next_options.nil?
        return_client_request_id = compute_node_list_next_options.return_client_request_id
      end
      unless compute_node_list_next_options.nil?
        ocp_date = compute_node_list_next_options.ocp_date
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; odata=minimalmetadata; charset=utf-8'

      # Set Headers
      request_headers['client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      request_headers['client-request-id'] = client_request_id.to_s unless client_request_id.to_s.nil?
      request_headers['return-client-request-id'] = return_client_request_id.to_s unless return_client_request_id.to_s.nil?
      request_headers['ocp-date'] = ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT') unless ocp_date.strftime('%a, %d %b %Y %H:%M:%S GMT').nil?
      path_template = '{nextLink}'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['request-id'] unless http_response['request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['client-request-id'] unless http_response['client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::Batch::V2019_06_01_9_0::Models::ComputeNodeListResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the Compute Nodes in the specified Pool.
    #
    # @param pool_id [String] The ID of the Pool from which you want to list
    # Compute Nodes.
    # @param compute_node_list_options [ComputeNodeListOptions] Additional
    # parameters for the operation
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ComputeNodeListResult] which provide lazy access to pages of the
    # response.
    #
    def list_as_lazy(pool_id, compute_node_list_options:nil, custom_headers:nil)
      response = list_async(pool_id, compute_node_list_options:compute_node_list_options, custom_headers:custom_headers).value!
      unless response.nil?
        page = response.body
        page.next_method = Proc.new do |next_page_link|
          compute_node_list_next_options = compute_node_list_options
          list_next_async(next_page_link, compute_node_list_next_options:compute_node_list_next_options, custom_headers:custom_headers)
        end
        page
      end
    end

  end
end
