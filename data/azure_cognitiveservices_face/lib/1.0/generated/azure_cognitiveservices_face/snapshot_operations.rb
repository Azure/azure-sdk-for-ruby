# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Azure::CognitiveServices::Face::V1_0
  #
  # An API for face detection, verification, and identification.
  #
  class SnapshotOperations
    include MsRestAzure

    #
    # Creates and initializes a new instance of the SnapshotOperations class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
      @client = client
    end

    # @return [FaceClient] reference to the FaceClient
    attr_reader :client

    #
    # Submit an operation to take a snapshot of face list, large face list, person
    # group or large person group, with user-specified snapshot type, source object
    # id, apply scope and an optional user data.<br />
    # The snapshot interfaces are for users to backup and restore their face data
    # from one face subscription to another, inside same region or across regions.
    # The workflow contains two phases, user first calls Snapshot - Take to create
    # a copy of the source object and store it as a snapshot, then calls Snapshot -
    # Apply to paste the snapshot to target subscription. The snapshots are stored
    # in a centralized location (per Azure instance), so that they can be applied
    # cross accounts and regions.<br />
    # Taking snapshot is an asynchronous operation. An operation id can be obtained
    # from the "Operation-Location" field in response header, to be used in
    # OperationStatus - Get for tracking the progress of creating the snapshot. The
    # snapshot id will be included in the "resourceLocation" field in
    # OperationStatus - Get response when the operation status is "succeeded".<br
    # />
    # Snapshot taking time depends on the number of person and face entries in the
    # source object. It could be in seconds, or up to several hours for 1,000,000
    # persons with multiple faces.<br />
    # Snapshots will be automatically expired and cleaned in 48 hours after it is
    # created by Snapshot - Take. User can delete the snapshot using Snapshot -
    # Delete by themselves any time before expiration.<br />
    # Taking snapshot for a certain object will not block any other operations
    # against the object. All read-only operations (Get/List and
    # Identify/FindSimilar/Verify) can be conducted as usual. For all writable
    # operations, including Add/Update/Delete the source object or its
    # persons/faces and Train, they are not blocked but not recommended because
    # writable updates may not be reflected on the snapshot during its taking.
    # After snapshot taking is completed, all readable and writable operations can
    # work as normal. Snapshot will also include the training results of the source
    # object, which means target subscription the snapshot applied to does not need
    # re-train the target object before calling Identify/FindSimilar.<br />
    # * Free-tier subscription quota: 100 take operations per month.
    # * S0-tier subscription quota: 100 take operations per day.
    #
    # @param type [SnapshotObjectType] User specified type for the source object to
    # take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and
    # LargePersonGroup are supported. Possible values include: 'FaceList',
    # 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
    # @param object_id [String] User specified source object id to take snapshot
    # from.
    # @param apply_scope User specified array of target Face subscription ids for
    # the snapshot. For each snapshot, only subscriptions included in the
    # applyScope of Snapshot - Take can apply it.
    # @param user_data [String] User specified data about the snapshot for any
    # purpose. Length should not exceed 16KB.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def take(type, object_id, apply_scope, user_data = nil, custom_headers = nil)
      response = take_async(type, object_id, apply_scope, user_data, custom_headers).value!
      nil
    end

    #
    # Submit an operation to take a snapshot of face list, large face list, person
    # group or large person group, with user-specified snapshot type, source object
    # id, apply scope and an optional user data.<br />
    # The snapshot interfaces are for users to backup and restore their face data
    # from one face subscription to another, inside same region or across regions.
    # The workflow contains two phases, user first calls Snapshot - Take to create
    # a copy of the source object and store it as a snapshot, then calls Snapshot -
    # Apply to paste the snapshot to target subscription. The snapshots are stored
    # in a centralized location (per Azure instance), so that they can be applied
    # cross accounts and regions.<br />
    # Taking snapshot is an asynchronous operation. An operation id can be obtained
    # from the "Operation-Location" field in response header, to be used in
    # OperationStatus - Get for tracking the progress of creating the snapshot. The
    # snapshot id will be included in the "resourceLocation" field in
    # OperationStatus - Get response when the operation status is "succeeded".<br
    # />
    # Snapshot taking time depends on the number of person and face entries in the
    # source object. It could be in seconds, or up to several hours for 1,000,000
    # persons with multiple faces.<br />
    # Snapshots will be automatically expired and cleaned in 48 hours after it is
    # created by Snapshot - Take. User can delete the snapshot using Snapshot -
    # Delete by themselves any time before expiration.<br />
    # Taking snapshot for a certain object will not block any other operations
    # against the object. All read-only operations (Get/List and
    # Identify/FindSimilar/Verify) can be conducted as usual. For all writable
    # operations, including Add/Update/Delete the source object or its
    # persons/faces and Train, they are not blocked but not recommended because
    # writable updates may not be reflected on the snapshot during its taking.
    # After snapshot taking is completed, all readable and writable operations can
    # work as normal. Snapshot will also include the training results of the source
    # object, which means target subscription the snapshot applied to does not need
    # re-train the target object before calling Identify/FindSimilar.<br />
    # * Free-tier subscription quota: 100 take operations per month.
    # * S0-tier subscription quota: 100 take operations per day.
    #
    # @param type [SnapshotObjectType] User specified type for the source object to
    # take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and
    # LargePersonGroup are supported. Possible values include: 'FaceList',
    # 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
    # @param object_id [String] User specified source object id to take snapshot
    # from.
    # @param apply_scope User specified array of target Face subscription ids for
    # the snapshot. For each snapshot, only subscriptions included in the
    # applyScope of Snapshot - Take can apply it.
    # @param user_data [String] User specified data about the snapshot for any
    # purpose. Length should not exceed 16KB.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def take_with_http_info(type, object_id, apply_scope, user_data = nil, custom_headers = nil)
      take_async(type, object_id, apply_scope, user_data, custom_headers).value!
    end

    #
    # Submit an operation to take a snapshot of face list, large face list, person
    # group or large person group, with user-specified snapshot type, source object
    # id, apply scope and an optional user data.<br />
    # The snapshot interfaces are for users to backup and restore their face data
    # from one face subscription to another, inside same region or across regions.
    # The workflow contains two phases, user first calls Snapshot - Take to create
    # a copy of the source object and store it as a snapshot, then calls Snapshot -
    # Apply to paste the snapshot to target subscription. The snapshots are stored
    # in a centralized location (per Azure instance), so that they can be applied
    # cross accounts and regions.<br />
    # Taking snapshot is an asynchronous operation. An operation id can be obtained
    # from the "Operation-Location" field in response header, to be used in
    # OperationStatus - Get for tracking the progress of creating the snapshot. The
    # snapshot id will be included in the "resourceLocation" field in
    # OperationStatus - Get response when the operation status is "succeeded".<br
    # />
    # Snapshot taking time depends on the number of person and face entries in the
    # source object. It could be in seconds, or up to several hours for 1,000,000
    # persons with multiple faces.<br />
    # Snapshots will be automatically expired and cleaned in 48 hours after it is
    # created by Snapshot - Take. User can delete the snapshot using Snapshot -
    # Delete by themselves any time before expiration.<br />
    # Taking snapshot for a certain object will not block any other operations
    # against the object. All read-only operations (Get/List and
    # Identify/FindSimilar/Verify) can be conducted as usual. For all writable
    # operations, including Add/Update/Delete the source object or its
    # persons/faces and Train, they are not blocked but not recommended because
    # writable updates may not be reflected on the snapshot during its taking.
    # After snapshot taking is completed, all readable and writable operations can
    # work as normal. Snapshot will also include the training results of the source
    # object, which means target subscription the snapshot applied to does not need
    # re-train the target object before calling Identify/FindSimilar.<br />
    # * Free-tier subscription quota: 100 take operations per month.
    # * S0-tier subscription quota: 100 take operations per day.
    #
    # @param type [SnapshotObjectType] User specified type for the source object to
    # take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and
    # LargePersonGroup are supported. Possible values include: 'FaceList',
    # 'LargeFaceList', 'LargePersonGroup', 'PersonGroup'
    # @param object_id [String] User specified source object id to take snapshot
    # from.
    # @param apply_scope User specified array of target Face subscription ids for
    # the snapshot. For each snapshot, only subscriptions included in the
    # applyScope of Snapshot - Take can apply it.
    # @param user_data [String] User specified data about the snapshot for any
    # purpose. Length should not exceed 16KB.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def take_async(type, object_id, apply_scope, user_data = nil, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'type is nil' if type.nil?
      fail ArgumentError, 'object_id is nil' if object_id.nil?
      fail ArgumentError, 'apply_scope is nil' if apply_scope.nil?

      body = TakeSnapshotRequest.new
      unless type.nil? && object_id.nil? && apply_scope.nil? && user_data.nil?
        body.type = type
        body.object_id = object_id
        body.apply_scope = apply_scope
        body.user_data = user_data
      end

      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Azure::CognitiveServices::Face::V1_0::Models::TakeSnapshotRequest.mapper()
      request_content = @client.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'snapshots'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 202
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # List all accessible snapshots with related information, including snapshots
    # that were taken by the user, or snapshots to be applied to the user
    # (subscription id was included in the applyScope in Snapshot - Take).
    #
    # @param type [SnapshotObjectType] User specified object type as a search
    # filter. Possible values include: 'FaceList', 'LargeFaceList',
    # 'LargePersonGroup', 'PersonGroup'
    # @param apply_scope User specified snapshot apply scopes as a search filter.
    # ApplyScope is an array of the target Azure subscription ids for the snapshot,
    # specified by the user who created the snapshot by Snapshot - Take.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list(type = nil, apply_scope = nil, custom_headers = nil)
      response = list_async(type, apply_scope, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all accessible snapshots with related information, including snapshots
    # that were taken by the user, or snapshots to be applied to the user
    # (subscription id was included in the applyScope in Snapshot - Take).
    #
    # @param type [SnapshotObjectType] User specified object type as a search
    # filter. Possible values include: 'FaceList', 'LargeFaceList',
    # 'LargePersonGroup', 'PersonGroup'
    # @param apply_scope User specified snapshot apply scopes as a search filter.
    # ApplyScope is an array of the target Azure subscription ids for the snapshot,
    # specified by the user who created the snapshot by Snapshot - Take.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def list_with_http_info(type = nil, apply_scope = nil, custom_headers = nil)
      list_async(type, apply_scope, custom_headers).value!
    end

    #
    # List all accessible snapshots with related information, including snapshots
    # that were taken by the user, or snapshots to be applied to the user
    # (subscription id was included in the applyScope in Snapshot - Take).
    #
    # @param type [SnapshotObjectType] User specified object type as a search
    # filter. Possible values include: 'FaceList', 'LargeFaceList',
    # 'LargePersonGroup', 'PersonGroup'
    # @param apply_scope User specified snapshot apply scopes as a search filter.
    # ApplyScope is an array of the target Azure subscription ids for the snapshot,
    # specified by the user who created the snapshot by Snapshot - Take.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_async(type = nil, apply_scope = nil, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = 'snapshots'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'type' => type,'applyScope' => apply_scope.nil? ? nil : apply_scope.join(',')},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'SnapshotElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'Snapshot'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Retrieve information about a snapshot. Snapshot is only accessible to the
    # source subscription who took it, and target subscriptions included in the
    # applyScope in Snapshot - Take.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Snapshot] operation results.
    #
    def get(snapshot_id, custom_headers = nil)
      response = get_async(snapshot_id, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Retrieve information about a snapshot. Snapshot is only accessible to the
    # source subscription who took it, and target subscriptions included in the
    # applyScope in Snapshot - Take.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_with_http_info(snapshot_id, custom_headers = nil)
      get_async(snapshot_id, custom_headers).value!
    end

    #
    # Retrieve information about a snapshot. Snapshot is only accessible to the
    # source subscription who took it, and target subscriptions included in the
    # applyScope in Snapshot - Take.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_async(snapshot_id, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'snapshot_id is nil' if snapshot_id.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = 'snapshots/{snapshotId}'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'snapshotId' => snapshot_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::CognitiveServices::Face::V1_0::Models::Snapshot.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Update the information of a snapshot. Only the source subscription who took
    # the snapshot can update the snapshot.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param apply_scope Array of the target Face subscription ids for the
    # snapshot, specified by the user who created the snapshot when calling
    # Snapshot - Take. For each snapshot, only subscriptions included in the
    # applyScope of Snapshot - Take can apply it.
    # @param user_data [String] User specified data about the snapshot for any
    # purpose. Length should not exceed 16KB.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def update(snapshot_id, apply_scope = nil, user_data = nil, custom_headers = nil)
      response = update_async(snapshot_id, apply_scope, user_data, custom_headers).value!
      nil
    end

    #
    # Update the information of a snapshot. Only the source subscription who took
    # the snapshot can update the snapshot.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param apply_scope Array of the target Face subscription ids for the
    # snapshot, specified by the user who created the snapshot when calling
    # Snapshot - Take. For each snapshot, only subscriptions included in the
    # applyScope of Snapshot - Take can apply it.
    # @param user_data [String] User specified data about the snapshot for any
    # purpose. Length should not exceed 16KB.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def update_with_http_info(snapshot_id, apply_scope = nil, user_data = nil, custom_headers = nil)
      update_async(snapshot_id, apply_scope, user_data, custom_headers).value!
    end

    #
    # Update the information of a snapshot. Only the source subscription who took
    # the snapshot can update the snapshot.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param apply_scope Array of the target Face subscription ids for the
    # snapshot, specified by the user who created the snapshot when calling
    # Snapshot - Take. For each snapshot, only subscriptions included in the
    # applyScope of Snapshot - Take can apply it.
    # @param user_data [String] User specified data about the snapshot for any
    # purpose. Length should not exceed 16KB.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_async(snapshot_id, apply_scope = nil, user_data = nil, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'snapshot_id is nil' if snapshot_id.nil?

      body = UpdateSnapshotRequest.new
      unless apply_scope.nil? && user_data.nil?
        body.apply_scope = apply_scope
        body.user_data = user_data
      end

      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Azure::CognitiveServices::Face::V1_0::Models::UpdateSnapshotRequest.mapper()
      request_content = @client.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'snapshots/{snapshotId}'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'snapshotId' => snapshot_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRestAzure::AzureOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Delete an existing snapshot according to the snapshotId. All object data and
    # information in the snapshot will also be deleted. Only the source
    # subscription who took the snapshot can delete the snapshot. If the user does
    # not delete a snapshot with this API, the snapshot will still be automatically
    # deleted in 48 hours after creation.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete(snapshot_id, custom_headers = nil)
      response = delete_async(snapshot_id, custom_headers).value!
      nil
    end

    #
    # Delete an existing snapshot according to the snapshotId. All object data and
    # information in the snapshot will also be deleted. Only the source
    # subscription who took the snapshot can delete the snapshot. If the user does
    # not delete a snapshot with this API, the snapshot will still be automatically
    # deleted in 48 hours after creation.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_with_http_info(snapshot_id, custom_headers = nil)
      delete_async(snapshot_id, custom_headers).value!
    end

    #
    # Delete an existing snapshot according to the snapshotId. All object data and
    # information in the snapshot will also be deleted. Only the source
    # subscription who took the snapshot can delete the snapshot. If the user does
    # not delete a snapshot with this API, the snapshot will still be automatically
    # deleted in 48 hours after creation.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_async(snapshot_id, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'snapshot_id is nil' if snapshot_id.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = 'snapshots/{snapshotId}'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'snapshotId' => snapshot_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRestAzure::AzureOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Submit an operation to apply a snapshot to current subscription. For each
    # snapshot, only subscriptions included in the applyScope of Snapshot - Take
    # can apply it.<br />
    # The snapshot interfaces are for users to backup and restore their face data
    # from one face subscription to another, inside same region or across regions.
    # The workflow contains two phases, user first calls Snapshot - Take to create
    # a copy of the source object and store it as a snapshot, then calls Snapshot -
    # Apply to paste the snapshot to target subscription. The snapshots are stored
    # in a centralized location (per Azure instance), so that they can be applied
    # cross accounts and regions.<br />
    # Applying snapshot is an asynchronous operation. An operation id can be
    # obtained from the "Operation-Location" field in response header, to be used
    # in OperationStatus - Get for tracking the progress of applying the snapshot.
    # The target object id will be included in the "resourceLocation" field in
    # OperationStatus - Get response when the operation status is "succeeded".<br
    # />
    # Snapshot applying time depends on the number of person and face entries in
    # the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000
    # persons with multiple faces.<br />
    # Snapshots will be automatically expired and cleaned in 48 hours after it is
    # created by Snapshot - Take. So the target subscription is required to apply
    # the snapshot in 48 hours since its creation.<br />
    # Applying a snapshot will not block any other operations against the target
    # object, however it is not recommended because the correctness cannot be
    # guaranteed during snapshot applying. After snapshot applying is completed,
    # all operations towards the target object can work as normal. Snapshot also
    # includes the training results of the source object, which means target
    # subscription the snapshot applied to does not need re-train the target object
    # before calling Identify/FindSimilar.<br />
    # One snapshot can be applied multiple times in parallel, while currently only
    # CreateNew apply mode is supported, which means the apply operation will fail
    # if target subscription already contains an object of same type and using the
    # same objectId. Users can specify the "objectId" in request body to avoid such
    # conflicts.<br />
    # * Free-tier subscription quota: 100 apply operations per month.
    # * S0-tier subscription quota: 100 apply operations per day.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param object_id [String] User specified target object id to be created from
    # the snapshot.
    # @param mode [SnapshotApplyMode] Snapshot applying mode. Currently only
    # CreateNew is supported, which means the apply operation will fail if target
    # subscription already contains an object of same type and using the same
    # objectId. Users can specify the "objectId" in request body to avoid such
    # conflicts. Possible values include: 'CreateNew'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def apply(snapshot_id, object_id, mode = nil, custom_headers = nil)
      response = apply_async(snapshot_id, object_id, mode, custom_headers).value!
      nil
    end

    #
    # Submit an operation to apply a snapshot to current subscription. For each
    # snapshot, only subscriptions included in the applyScope of Snapshot - Take
    # can apply it.<br />
    # The snapshot interfaces are for users to backup and restore their face data
    # from one face subscription to another, inside same region or across regions.
    # The workflow contains two phases, user first calls Snapshot - Take to create
    # a copy of the source object and store it as a snapshot, then calls Snapshot -
    # Apply to paste the snapshot to target subscription. The snapshots are stored
    # in a centralized location (per Azure instance), so that they can be applied
    # cross accounts and regions.<br />
    # Applying snapshot is an asynchronous operation. An operation id can be
    # obtained from the "Operation-Location" field in response header, to be used
    # in OperationStatus - Get for tracking the progress of applying the snapshot.
    # The target object id will be included in the "resourceLocation" field in
    # OperationStatus - Get response when the operation status is "succeeded".<br
    # />
    # Snapshot applying time depends on the number of person and face entries in
    # the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000
    # persons with multiple faces.<br />
    # Snapshots will be automatically expired and cleaned in 48 hours after it is
    # created by Snapshot - Take. So the target subscription is required to apply
    # the snapshot in 48 hours since its creation.<br />
    # Applying a snapshot will not block any other operations against the target
    # object, however it is not recommended because the correctness cannot be
    # guaranteed during snapshot applying. After snapshot applying is completed,
    # all operations towards the target object can work as normal. Snapshot also
    # includes the training results of the source object, which means target
    # subscription the snapshot applied to does not need re-train the target object
    # before calling Identify/FindSimilar.<br />
    # One snapshot can be applied multiple times in parallel, while currently only
    # CreateNew apply mode is supported, which means the apply operation will fail
    # if target subscription already contains an object of same type and using the
    # same objectId. Users can specify the "objectId" in request body to avoid such
    # conflicts.<br />
    # * Free-tier subscription quota: 100 apply operations per month.
    # * S0-tier subscription quota: 100 apply operations per day.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param object_id [String] User specified target object id to be created from
    # the snapshot.
    # @param mode [SnapshotApplyMode] Snapshot applying mode. Currently only
    # CreateNew is supported, which means the apply operation will fail if target
    # subscription already contains an object of same type and using the same
    # objectId. Users can specify the "objectId" in request body to avoid such
    # conflicts. Possible values include: 'CreateNew'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def apply_with_http_info(snapshot_id, object_id, mode = nil, custom_headers = nil)
      apply_async(snapshot_id, object_id, mode, custom_headers).value!
    end

    #
    # Submit an operation to apply a snapshot to current subscription. For each
    # snapshot, only subscriptions included in the applyScope of Snapshot - Take
    # can apply it.<br />
    # The snapshot interfaces are for users to backup and restore their face data
    # from one face subscription to another, inside same region or across regions.
    # The workflow contains two phases, user first calls Snapshot - Take to create
    # a copy of the source object and store it as a snapshot, then calls Snapshot -
    # Apply to paste the snapshot to target subscription. The snapshots are stored
    # in a centralized location (per Azure instance), so that they can be applied
    # cross accounts and regions.<br />
    # Applying snapshot is an asynchronous operation. An operation id can be
    # obtained from the "Operation-Location" field in response header, to be used
    # in OperationStatus - Get for tracking the progress of applying the snapshot.
    # The target object id will be included in the "resourceLocation" field in
    # OperationStatus - Get response when the operation status is "succeeded".<br
    # />
    # Snapshot applying time depends on the number of person and face entries in
    # the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000
    # persons with multiple faces.<br />
    # Snapshots will be automatically expired and cleaned in 48 hours after it is
    # created by Snapshot - Take. So the target subscription is required to apply
    # the snapshot in 48 hours since its creation.<br />
    # Applying a snapshot will not block any other operations against the target
    # object, however it is not recommended because the correctness cannot be
    # guaranteed during snapshot applying. After snapshot applying is completed,
    # all operations towards the target object can work as normal. Snapshot also
    # includes the training results of the source object, which means target
    # subscription the snapshot applied to does not need re-train the target object
    # before calling Identify/FindSimilar.<br />
    # One snapshot can be applied multiple times in parallel, while currently only
    # CreateNew apply mode is supported, which means the apply operation will fail
    # if target subscription already contains an object of same type and using the
    # same objectId. Users can specify the "objectId" in request body to avoid such
    # conflicts.<br />
    # * Free-tier subscription quota: 100 apply operations per month.
    # * S0-tier subscription quota: 100 apply operations per day.
    #
    # @param snapshot_id Id referencing a particular snapshot.
    # @param object_id [String] User specified target object id to be created from
    # the snapshot.
    # @param mode [SnapshotApplyMode] Snapshot applying mode. Currently only
    # CreateNew is supported, which means the apply operation will fail if target
    # subscription already contains an object of same type and using the same
    # objectId. Users can specify the "objectId" in request body to avoid such
    # conflicts. Possible values include: 'CreateNew'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def apply_async(snapshot_id, object_id, mode = nil, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'snapshot_id is nil' if snapshot_id.nil?
      fail ArgumentError, 'object_id is nil' if object_id.nil?

      body = ApplySnapshotRequest.new
      unless object_id.nil? && mode.nil?
        body.object_id = object_id
        body.mode = mode
      end

      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Azure::CognitiveServices::Face::V1_0::Models::ApplySnapshotRequest.mapper()
      request_content = @client.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'snapshots/{snapshotId}/apply'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'snapshotId' => snapshot_id},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 202
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Retrieve the status of a take/apply snapshot operation.
    #
    # @param operation_id Id referencing a particular take/apply snapshot
    # operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [OperationStatus] operation results.
    #
    def get_operation_status(operation_id, custom_headers = nil)
      response = get_operation_status_async(operation_id, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Retrieve the status of a take/apply snapshot operation.
    #
    # @param operation_id Id referencing a particular take/apply snapshot
    # operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_operation_status_with_http_info(operation_id, custom_headers = nil)
      get_operation_status_async(operation_id, custom_headers).value!
    end

    #
    # Retrieve the status of a take/apply snapshot operation.
    #
    # @param operation_id Id referencing a particular take/apply snapshot
    # operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_operation_status_async(operation_id, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'operation_id is nil' if operation_id.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?
      path_template = 'operations/{operationId}'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'operationId' => operation_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::CognitiveServices::Face::V1_0::Models::OperationStatus.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

  end
end
