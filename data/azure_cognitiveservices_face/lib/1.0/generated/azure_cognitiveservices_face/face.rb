# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Azure::CognitiveServices::Face::V1_0
  #
  # An API for face detection, verification, and identification.
  #
  class Face
    include MsRestAzure

    #
    # Creates and initializes a new instance of the Face class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
      @client = client
    end

    # @return [FaceClient] reference to the FaceClient
    attr_reader :client

    #
    # Given query face's faceId, find the similar-looking faces from a faceId
    # array, a face list or a large face list.
    #
    # @param face_id FaceId of the query face. User needs to call Face - Detect
    # first to get a valid faceId. Note that this faceId is not persisted and will
    # expire 24 hours after the detection call
    # @param face_list_id [String] An existing user-specified unique candidate face
    # list, created in Face List - Create a Face List. Face list contains a set of
    # persistedFaceIds which are persisted and will never expire. Parameter
    # faceListId, largeFaceListId and faceIds should not be provided at the same
    # time.
    # @param large_face_list_id [String] An existing user-specified unique
    # candidate large face list, created in LargeFaceList - Create. Large face list
    # contains a set of persistedFaceIds which are persisted and will never expire.
    # Parameter faceListId, largeFaceListId and faceIds should not be provided at
    # the same time.
    # @param face_ids An array of candidate faceIds. All of them are created by
    # Face - Detect and the faceIds will expire 24 hours after the detection call.
    # The number of faceIds is limited to 1000. Parameter faceListId,
    # largeFaceListId and faceIds should not be provided at the same time.
    # @param max_num_of_candidates_returned [Integer] The number of top similar
    # faces returned. The valid range is [1, 1000].
    # @param mode [FindSimilarMatchMode] Similar face searching mode. It can be
    # "matchPerson" or "matchFace". Possible values include: 'matchPerson',
    # 'matchFace'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def find_similar(face_id, face_list_id = nil, large_face_list_id = nil, face_ids = nil, max_num_of_candidates_returned = 20, mode = nil, custom_headers = nil)
      response = find_similar_async(face_id, face_list_id, large_face_list_id, face_ids, max_num_of_candidates_returned, mode, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Given query face's faceId, find the similar-looking faces from a faceId
    # array, a face list or a large face list.
    #
    # @param face_id FaceId of the query face. User needs to call Face - Detect
    # first to get a valid faceId. Note that this faceId is not persisted and will
    # expire 24 hours after the detection call
    # @param face_list_id [String] An existing user-specified unique candidate face
    # list, created in Face List - Create a Face List. Face list contains a set of
    # persistedFaceIds which are persisted and will never expire. Parameter
    # faceListId, largeFaceListId and faceIds should not be provided at the same
    # time.
    # @param large_face_list_id [String] An existing user-specified unique
    # candidate large face list, created in LargeFaceList - Create. Large face list
    # contains a set of persistedFaceIds which are persisted and will never expire.
    # Parameter faceListId, largeFaceListId and faceIds should not be provided at
    # the same time.
    # @param face_ids An array of candidate faceIds. All of them are created by
    # Face - Detect and the faceIds will expire 24 hours after the detection call.
    # The number of faceIds is limited to 1000. Parameter faceListId,
    # largeFaceListId and faceIds should not be provided at the same time.
    # @param max_num_of_candidates_returned [Integer] The number of top similar
    # faces returned. The valid range is [1, 1000].
    # @param mode [FindSimilarMatchMode] Similar face searching mode. It can be
    # "matchPerson" or "matchFace". Possible values include: 'matchPerson',
    # 'matchFace'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def find_similar_with_http_info(face_id, face_list_id = nil, large_face_list_id = nil, face_ids = nil, max_num_of_candidates_returned = 20, mode = nil, custom_headers = nil)
      find_similar_async(face_id, face_list_id, large_face_list_id, face_ids, max_num_of_candidates_returned, mode, custom_headers).value!
    end

    #
    # Given query face's faceId, find the similar-looking faces from a faceId
    # array, a face list or a large face list.
    #
    # @param face_id FaceId of the query face. User needs to call Face - Detect
    # first to get a valid faceId. Note that this faceId is not persisted and will
    # expire 24 hours after the detection call
    # @param face_list_id [String] An existing user-specified unique candidate face
    # list, created in Face List - Create a Face List. Face list contains a set of
    # persistedFaceIds which are persisted and will never expire. Parameter
    # faceListId, largeFaceListId and faceIds should not be provided at the same
    # time.
    # @param large_face_list_id [String] An existing user-specified unique
    # candidate large face list, created in LargeFaceList - Create. Large face list
    # contains a set of persistedFaceIds which are persisted and will never expire.
    # Parameter faceListId, largeFaceListId and faceIds should not be provided at
    # the same time.
    # @param face_ids An array of candidate faceIds. All of them are created by
    # Face - Detect and the faceIds will expire 24 hours after the detection call.
    # The number of faceIds is limited to 1000. Parameter faceListId,
    # largeFaceListId and faceIds should not be provided at the same time.
    # @param max_num_of_candidates_returned [Integer] The number of top similar
    # faces returned. The valid range is [1, 1000].
    # @param mode [FindSimilarMatchMode] Similar face searching mode. It can be
    # "matchPerson" or "matchFace". Possible values include: 'matchPerson',
    # 'matchFace'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def find_similar_async(face_id, face_list_id = nil, large_face_list_id = nil, face_ids = nil, max_num_of_candidates_returned = 20, mode = nil, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'face_id is nil' if face_id.nil?

      body = FindSimilarRequest.new
      unless face_id.nil? && face_list_id.nil? && large_face_list_id.nil? && face_ids.nil? && max_num_of_candidates_returned.nil? && mode.nil?
        body.face_id = face_id
        body.face_list_id = face_list_id
        body.large_face_list_id = large_face_list_id
        body.face_ids = face_ids
        body.max_num_of_candidates_returned = max_num_of_candidates_returned
        body.mode = mode
      end

      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Azure::CognitiveServices::Face::V1_0::Models::FindSimilarRequest.mapper()
      request_content = @client.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'findsimilars'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'SimilarFaceElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'SimilarFace'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Divide candidate faces into groups based on face similarity.
    #
    # @param face_ids Array of candidate faceId created by Face - Detect. The
    # maximum is 1000 faces
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [GroupResult] operation results.
    #
    def group(face_ids, custom_headers = nil)
      response = group_async(face_ids, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Divide candidate faces into groups based on face similarity.
    #
    # @param face_ids Array of candidate faceId created by Face - Detect. The
    # maximum is 1000 faces
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def group_with_http_info(face_ids, custom_headers = nil)
      group_async(face_ids, custom_headers).value!
    end

    #
    # Divide candidate faces into groups based on face similarity.
    #
    # @param face_ids Array of candidate faceId created by Face - Detect. The
    # maximum is 1000 faces
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def group_async(face_ids, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'face_ids is nil' if face_ids.nil?

      body = GroupRequest.new
      unless face_ids.nil?
        body.face_ids = face_ids
      end

      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Azure::CognitiveServices::Face::V1_0::Models::GroupRequest.mapper()
      request_content = @client.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'group'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::CognitiveServices::Face::V1_0::Models::GroupResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # 1-to-many identification to find the closest matches of the specific query
    # person face from a person group or large person group.
    #
    # @param face_ids Array of query faces faceIds, created by the Face - Detect.
    # Each of the faces are identified independently. The valid number of faceIds
    # is between [1, 10].
    # @param person_group_id [String] PersonGroupId of the target person group,
    # created by PersonGroup - Create. Parameter personGroupId and
    # largePersonGroupId should not be provided at the same time.
    # @param large_person_group_id [String] LargePersonGroupId of the target large
    # person group, created by LargePersonGroup - Create. Parameter personGroupId
    # and largePersonGroupId should not be provided at the same time.
    # @param max_num_of_candidates_returned [Integer] The range of
    # maxNumOfCandidatesReturned is between 1 and 5 (default is 1).
    # @param confidence_threshold [Float] Confidence threshold of identification,
    # used to judge whether one face belong to one person. The range of
    # confidenceThreshold is [0, 1] (default specified by algorithm).
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def identify(face_ids, person_group_id = nil, large_person_group_id = nil, max_num_of_candidates_returned = 1, confidence_threshold = nil, custom_headers = nil)
      response = identify_async(face_ids, person_group_id, large_person_group_id, max_num_of_candidates_returned, confidence_threshold, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # 1-to-many identification to find the closest matches of the specific query
    # person face from a person group or large person group.
    #
    # @param face_ids Array of query faces faceIds, created by the Face - Detect.
    # Each of the faces are identified independently. The valid number of faceIds
    # is between [1, 10].
    # @param person_group_id [String] PersonGroupId of the target person group,
    # created by PersonGroup - Create. Parameter personGroupId and
    # largePersonGroupId should not be provided at the same time.
    # @param large_person_group_id [String] LargePersonGroupId of the target large
    # person group, created by LargePersonGroup - Create. Parameter personGroupId
    # and largePersonGroupId should not be provided at the same time.
    # @param max_num_of_candidates_returned [Integer] The range of
    # maxNumOfCandidatesReturned is between 1 and 5 (default is 1).
    # @param confidence_threshold [Float] Confidence threshold of identification,
    # used to judge whether one face belong to one person. The range of
    # confidenceThreshold is [0, 1] (default specified by algorithm).
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def identify_with_http_info(face_ids, person_group_id = nil, large_person_group_id = nil, max_num_of_candidates_returned = 1, confidence_threshold = nil, custom_headers = nil)
      identify_async(face_ids, person_group_id, large_person_group_id, max_num_of_candidates_returned, confidence_threshold, custom_headers).value!
    end

    #
    # 1-to-many identification to find the closest matches of the specific query
    # person face from a person group or large person group.
    #
    # @param face_ids Array of query faces faceIds, created by the Face - Detect.
    # Each of the faces are identified independently. The valid number of faceIds
    # is between [1, 10].
    # @param person_group_id [String] PersonGroupId of the target person group,
    # created by PersonGroup - Create. Parameter personGroupId and
    # largePersonGroupId should not be provided at the same time.
    # @param large_person_group_id [String] LargePersonGroupId of the target large
    # person group, created by LargePersonGroup - Create. Parameter personGroupId
    # and largePersonGroupId should not be provided at the same time.
    # @param max_num_of_candidates_returned [Integer] The range of
    # maxNumOfCandidatesReturned is between 1 and 5 (default is 1).
    # @param confidence_threshold [Float] Confidence threshold of identification,
    # used to judge whether one face belong to one person. The range of
    # confidenceThreshold is [0, 1] (default specified by algorithm).
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def identify_async(face_ids, person_group_id = nil, large_person_group_id = nil, max_num_of_candidates_returned = 1, confidence_threshold = nil, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'face_ids is nil' if face_ids.nil?

      body = IdentifyRequest.new
      unless face_ids.nil? && person_group_id.nil? && large_person_group_id.nil? && max_num_of_candidates_returned.nil? && confidence_threshold.nil?
        body.face_ids = face_ids
        body.person_group_id = person_group_id
        body.large_person_group_id = large_person_group_id
        body.max_num_of_candidates_returned = max_num_of_candidates_returned
        body.confidence_threshold = confidence_threshold
      end

      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Azure::CognitiveServices::Face::V1_0::Models::IdentifyRequest.mapper()
      request_content = @client.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'identify'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'IdentifyResultElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'IdentifyResult'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Verify whether two faces belong to a same person or whether one face belongs
    # to a person.
    #
    # @param face_id1 FaceId of the first face, comes from Face - Detect
    # @param face_id2 FaceId of the second face, comes from Face - Detect
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerifyResult] operation results.
    #
    def verify_face_to_face(face_id1, face_id2, custom_headers = nil)
      response = verify_face_to_face_async(face_id1, face_id2, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Verify whether two faces belong to a same person or whether one face belongs
    # to a person.
    #
    # @param face_id1 FaceId of the first face, comes from Face - Detect
    # @param face_id2 FaceId of the second face, comes from Face - Detect
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def verify_face_to_face_with_http_info(face_id1, face_id2, custom_headers = nil)
      verify_face_to_face_async(face_id1, face_id2, custom_headers).value!
    end

    #
    # Verify whether two faces belong to a same person or whether one face belongs
    # to a person.
    #
    # @param face_id1 FaceId of the first face, comes from Face - Detect
    # @param face_id2 FaceId of the second face, comes from Face - Detect
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def verify_face_to_face_async(face_id1, face_id2, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'face_id1 is nil' if face_id1.nil?
      fail ArgumentError, 'face_id2 is nil' if face_id2.nil?

      body = VerifyFaceToFaceRequest.new
      unless face_id1.nil? && face_id2.nil?
        body.face_id1 = face_id1
        body.face_id2 = face_id2
      end

      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Azure::CognitiveServices::Face::V1_0::Models::VerifyFaceToFaceRequest.mapper()
      request_content = @client.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'verify'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::CognitiveServices::Face::V1_0::Models::VerifyResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Detect human faces in an image and returns face locations, and optionally
    # with faceIds, landmarks, and attributes.
    #
    # @param url [String] Publicly reachable URL of an image
    # @param return_face_id [Boolean] A value indicating whether the operation
    # should return faceIds of detected faces.
    # @param return_face_landmarks [Boolean] A value indicating whether the
    # operation should return landmarks of the detected faces.
    # @param return_face_attributes [Array<FaceAttributeType>] Analyze and return
    # the one or more specified face attributes in the comma-separated string like
    # "returnFaceAttributes=age,gender". Supported face attributes include age,
    # gender, headPose, smile, facialHair, glasses and emotion. Note that each face
    # attribute analysis has additional computational and time cost.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def detect_with_url(url, return_face_id = true, return_face_landmarks = false, return_face_attributes = nil, custom_headers = nil)
      response = detect_with_url_async(url, return_face_id, return_face_landmarks, return_face_attributes, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Detect human faces in an image and returns face locations, and optionally
    # with faceIds, landmarks, and attributes.
    #
    # @param url [String] Publicly reachable URL of an image
    # @param return_face_id [Boolean] A value indicating whether the operation
    # should return faceIds of detected faces.
    # @param return_face_landmarks [Boolean] A value indicating whether the
    # operation should return landmarks of the detected faces.
    # @param return_face_attributes [Array<FaceAttributeType>] Analyze and return
    # the one or more specified face attributes in the comma-separated string like
    # "returnFaceAttributes=age,gender". Supported face attributes include age,
    # gender, headPose, smile, facialHair, glasses and emotion. Note that each face
    # attribute analysis has additional computational and time cost.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def detect_with_url_with_http_info(url, return_face_id = true, return_face_landmarks = false, return_face_attributes = nil, custom_headers = nil)
      detect_with_url_async(url, return_face_id, return_face_landmarks, return_face_attributes, custom_headers).value!
    end

    #
    # Detect human faces in an image and returns face locations, and optionally
    # with faceIds, landmarks, and attributes.
    #
    # @param url [String] Publicly reachable URL of an image
    # @param return_face_id [Boolean] A value indicating whether the operation
    # should return faceIds of detected faces.
    # @param return_face_landmarks [Boolean] A value indicating whether the
    # operation should return landmarks of the detected faces.
    # @param return_face_attributes [Array<FaceAttributeType>] Analyze and return
    # the one or more specified face attributes in the comma-separated string like
    # "returnFaceAttributes=age,gender". Supported face attributes include age,
    # gender, headPose, smile, facialHair, glasses and emotion. Note that each face
    # attribute analysis has additional computational and time cost.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def detect_with_url_async(url, return_face_id = true, return_face_landmarks = false, return_face_attributes = nil, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'url is nil' if url.nil?

      image_url = ImageUrl.new
      unless url.nil?
        image_url.url = url
      end

      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Azure::CognitiveServices::Face::V1_0::Models::ImageUrl.mapper()
      request_content = @client.serialize(request_mapper,  image_url)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'detect'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'returnFaceId' => return_face_id,'returnFaceLandmarks' => return_face_landmarks,'returnFaceAttributes' => return_face_attributes.nil? ? nil : return_face_attributes.join(',')},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'DetectedFaceElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'DetectedFace'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Verify whether two faces belong to a same person. Compares a face Id with a
    # Person Id
    #
    # @param face_id FaceId of the face, comes from Face - Detect
    # @param person_id Specify a certain person in a person group or a large person
    # group. personId is created in PersonGroup Person - Create or LargePersonGroup
    # Person - Create.
    # @param person_group_id [String] Using existing personGroupId and personId for
    # fast loading a specified person. personGroupId is created in PersonGroup -
    # Create. Parameter personGroupId and largePersonGroupId should not be provided
    # at the same time.
    # @param large_person_group_id [String] Using existing largePersonGroupId and
    # personId for fast loading a specified person. largePersonGroupId is created
    # in LargePersonGroup - Create. Parameter personGroupId and largePersonGroupId
    # should not be provided at the same time.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VerifyResult] operation results.
    #
    def verify_face_to_person(face_id, person_id, person_group_id = nil, large_person_group_id = nil, custom_headers = nil)
      response = verify_face_to_person_async(face_id, person_id, person_group_id, large_person_group_id, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Verify whether two faces belong to a same person. Compares a face Id with a
    # Person Id
    #
    # @param face_id FaceId of the face, comes from Face - Detect
    # @param person_id Specify a certain person in a person group or a large person
    # group. personId is created in PersonGroup Person - Create or LargePersonGroup
    # Person - Create.
    # @param person_group_id [String] Using existing personGroupId and personId for
    # fast loading a specified person. personGroupId is created in PersonGroup -
    # Create. Parameter personGroupId and largePersonGroupId should not be provided
    # at the same time.
    # @param large_person_group_id [String] Using existing largePersonGroupId and
    # personId for fast loading a specified person. largePersonGroupId is created
    # in LargePersonGroup - Create. Parameter personGroupId and largePersonGroupId
    # should not be provided at the same time.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def verify_face_to_person_with_http_info(face_id, person_id, person_group_id = nil, large_person_group_id = nil, custom_headers = nil)
      verify_face_to_person_async(face_id, person_id, person_group_id, large_person_group_id, custom_headers).value!
    end

    #
    # Verify whether two faces belong to a same person. Compares a face Id with a
    # Person Id
    #
    # @param face_id FaceId of the face, comes from Face - Detect
    # @param person_id Specify a certain person in a person group or a large person
    # group. personId is created in PersonGroup Person - Create or LargePersonGroup
    # Person - Create.
    # @param person_group_id [String] Using existing personGroupId and personId for
    # fast loading a specified person. personGroupId is created in PersonGroup -
    # Create. Parameter personGroupId and largePersonGroupId should not be provided
    # at the same time.
    # @param large_person_group_id [String] Using existing largePersonGroupId and
    # personId for fast loading a specified person. largePersonGroupId is created
    # in LargePersonGroup - Create. Parameter personGroupId and largePersonGroupId
    # should not be provided at the same time.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def verify_face_to_person_async(face_id, person_id, person_group_id = nil, large_person_group_id = nil, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'face_id is nil' if face_id.nil?
      fail ArgumentError, 'person_id is nil' if person_id.nil?

      body = VerifyFaceToPersonRequest.new
      unless face_id.nil? && person_group_id.nil? && large_person_group_id.nil? && person_id.nil?
        body.face_id = face_id
        body.person_group_id = person_group_id
        body.large_person_group_id = large_person_group_id
        body.person_id = person_id
      end

      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Azure::CognitiveServices::Face::V1_0::Models::VerifyFaceToPersonRequest.mapper()
      request_content = @client.serialize(request_mapper,  body)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'verify'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::CognitiveServices::Face::V1_0::Models::VerifyResult.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Detect human faces in an image and returns face locations, and optionally
    # with faceIds, landmarks, and attributes.
    #
    # @param image An image stream.
    # @param return_face_id [Boolean] A value indicating whether the operation
    # should return faceIds of detected faces.
    # @param return_face_landmarks [Boolean] A value indicating whether the
    # operation should return landmarks of the detected faces.
    # @param return_face_attributes [Array<FaceAttributeType>] Analyze and return
    # the one or more specified face attributes in the comma-separated string like
    # "returnFaceAttributes=age,gender". Supported face attributes include age,
    # gender, headPose, smile, facialHair, glasses and emotion. Note that each face
    # attribute analysis has additional computational and time cost.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def detect_with_stream(image, return_face_id = true, return_face_landmarks = false, return_face_attributes = nil, custom_headers = nil)
      response = detect_with_stream_async(image, return_face_id, return_face_landmarks, return_face_attributes, custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Detect human faces in an image and returns face locations, and optionally
    # with faceIds, landmarks, and attributes.
    #
    # @param image An image stream.
    # @param return_face_id [Boolean] A value indicating whether the operation
    # should return faceIds of detected faces.
    # @param return_face_landmarks [Boolean] A value indicating whether the
    # operation should return landmarks of the detected faces.
    # @param return_face_attributes [Array<FaceAttributeType>] Analyze and return
    # the one or more specified face attributes in the comma-separated string like
    # "returnFaceAttributes=age,gender". Supported face attributes include age,
    # gender, headPose, smile, facialHair, glasses and emotion. Note that each face
    # attribute analysis has additional computational and time cost.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def detect_with_stream_with_http_info(image, return_face_id = true, return_face_landmarks = false, return_face_attributes = nil, custom_headers = nil)
      detect_with_stream_async(image, return_face_id, return_face_landmarks, return_face_attributes, custom_headers).value!
    end

    #
    # Detect human faces in an image and returns face locations, and optionally
    # with faceIds, landmarks, and attributes.
    #
    # @param image An image stream.
    # @param return_face_id [Boolean] A value indicating whether the operation
    # should return faceIds of detected faces.
    # @param return_face_landmarks [Boolean] A value indicating whether the
    # operation should return landmarks of the detected faces.
    # @param return_face_attributes [Array<FaceAttributeType>] Analyze and return
    # the one or more specified face attributes in the comma-separated string like
    # "returnFaceAttributes=age,gender". Supported face attributes include age,
    # gender, headPose, smile, facialHair, glasses and emotion. Note that each face
    # attribute analysis has additional computational and time cost.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def detect_with_stream_async(image, return_face_id = true, return_face_landmarks = false, return_face_attributes = nil, custom_headers = nil)
      fail ArgumentError, '@client.endpoint is nil' if @client.endpoint.nil?
      fail ArgumentError, 'image is nil' if image.nil?


      request_headers = {}

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = @client.accept_language unless @client.accept_language.nil?

      request_headers['Content-Type'] = 'application/octet-stream'

      # Serialize Request
      request_mapper = {
        required: true,
        serialized_name: 'Image',
        type: {
          name: 'Stream'
        }
      }
      request_content = @client.serialize(request_mapper,  image)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'detect'

      request_url = @base_url || @client.base_url
    request_url = request_url.gsub('{Endpoint}', @client.endpoint)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'returnFaceId' => return_face_id,'returnFaceLandmarks' => return_face_landmarks,'returnFaceAttributes' => return_face_attributes.nil? ? nil : return_face_attributes.join(',')},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    required: false,
                    serialized_name: 'DetectedFaceElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'DetectedFace'
                    }
                }
              }
            }
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

  end
end
