# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Azure::KeyVault::V2016_10_01
  #
  # A service client - single point of access to the REST API.
  #
  class KeyVaultClient < MsRestAzure::AzureServiceClient
    include MsRestAzure
    include MsRestAzure::Serialization

    # @return [String] the base URI of the service.
    attr_reader :base_url

    # @return Credentials needed for the client to connect to Azure.
    attr_reader :credentials

    # @return [String] Client API version.
    attr_reader :api_version

    # @return [String] The preferred language for the response.
    attr_accessor :accept_language

    # @return [Integer] The retry timeout in seconds for Long Running
    # Operations. Default value is 30.
    attr_accessor :long_running_operation_retry_timeout

    # @return [Boolean] Whether a unique x-ms-client-request-id should be
    # generated. When set to true a unique x-ms-client-request-id value is
    # generated and included in each request. Default is true.
    attr_accessor :generate_client_request_id

    #
    # Creates initializes a new instance of the KeyVaultClient class.
    # @param credentials [MsRest::ServiceClientCredentials] credentials to authorize HTTP requests made by the service client.
    # @param options [Array] filters to be applied to the HTTP requests.
    #
    def initialize(credentials = nil, options = nil)
      super(credentials, options)
      @base_url = '{vaultBaseUrl}'

      fail ArgumentError, 'invalid type of credentials input parameter' unless credentials.is_a?(MsRest::ServiceClientCredentials) unless credentials.nil?
      @credentials = credentials

      @api_version = '2016-10-01'
      @accept_language = 'en-US'
      @long_running_operation_retry_timeout = 30
      @generate_client_request_id = true
      add_telemetry
    end

    #
    # Makes a request and returns the body of the response.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [Hash{String=>String}] containing the body of the response.
    # Example:
    #
    #  request_content = "{'location':'westus','tags':{'tag1':'val1','tag2':'val2'}}"
    #  path = "/path"
    #  options = {
    #    body: request_content,
    #    query_params: {'api-version' => '2016-02-01'}
    #  }
    #  result = @client.make_request(:put, path, options)
    #
    def make_request(method, path, options = {})
      result = make_request_with_http_info(method, path, options)
      result.body unless result.nil?
    end

    #
    # Makes a request and returns the operation response.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [MsRestAzure::AzureOperationResponse] Operation response containing the request, response and status.
    #
    def make_request_with_http_info(method, path, options = {})
      result = make_request_async(method, path, options).value!
      result.body = result.response.body.to_s.empty? ? nil : JSON.load(result.response.body)
      result
    end

    #
    # Makes a request asynchronously.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def make_request_async(method, path, options = {})
      fail ArgumentError, 'method is nil' if method.nil?
      fail ArgumentError, 'path is nil' if path.nil?

      request_url = options[:base_url] || @base_url
      if(!options[:headers].nil? && !options[:headers]['Content-Type'].nil?)
        @request_headers['Content-Type'] = options[:headers]['Content-Type']
      end

      request_headers = @request_headers
      request_headers.merge!({'accept-language' => @accept_language}) unless @accept_language.nil?
      options.merge!({headers: request_headers.merge(options[:headers] || {})})
      options.merge!({credentials: @credentials}) unless @credentials.nil?

      super(request_url, method, path, options)
    end

    #
    # Creates a new key, stores it, then returns key parameters and attributes to
    # the client.
    #
    # The create key operation can be used to create any key type in Azure Key
    # Vault. If the named key already exists, Azure Key Vault creates a new version
    # of the key. It requires the keys/create permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name for the new key. The system will generate
    # the version name for the new key.
    # @param kty [JsonWebKeyType] The type of key to create. For valid values, see
    # JsonWebKeyType. Possible values include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM',
    # 'oct'
    # @param key_size [Integer] The key size in bits. For example: 2048, 3072, or
    # 4096 for RSA.
    # @param key_ops [Array<JsonWebKeyOperation>]
    # @param key_attributes [KeyAttributes]
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param curve [JsonWebKeyCurveName] Elliptic curve name. For valid values, see
    # JsonWebKeyCurveName. Possible values include: 'P-256', 'P-384', 'P-521',
    # 'SECP256K1'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyBundle] operation results.
    #
    def create_key(vault_base_url, key_name, kty, key_size:nil, key_ops:nil, key_attributes:nil, tags:nil, curve:nil, custom_headers:nil)
      response = create_key_async(vault_base_url, key_name, kty, key_size:key_size, key_ops:key_ops, key_attributes:key_attributes, tags:tags, curve:curve, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new key, stores it, then returns key parameters and attributes to
    # the client.
    #
    # The create key operation can be used to create any key type in Azure Key
    # Vault. If the named key already exists, Azure Key Vault creates a new version
    # of the key. It requires the keys/create permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name for the new key. The system will generate
    # the version name for the new key.
    # @param kty [JsonWebKeyType] The type of key to create. For valid values, see
    # JsonWebKeyType. Possible values include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM',
    # 'oct'
    # @param key_size [Integer] The key size in bits. For example: 2048, 3072, or
    # 4096 for RSA.
    # @param key_ops [Array<JsonWebKeyOperation>]
    # @param key_attributes [KeyAttributes]
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param curve [JsonWebKeyCurveName] Elliptic curve name. For valid values, see
    # JsonWebKeyCurveName. Possible values include: 'P-256', 'P-384', 'P-521',
    # 'SECP256K1'
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def create_key_with_http_info(vault_base_url, key_name, kty, key_size:nil, key_ops:nil, key_attributes:nil, tags:nil, curve:nil, custom_headers:nil)
      create_key_async(vault_base_url, key_name, kty, key_size:key_size, key_ops:key_ops, key_attributes:key_attributes, tags:tags, curve:curve, custom_headers:custom_headers).value!
    end

    #
    # Creates a new key, stores it, then returns key parameters and attributes to
    # the client.
    #
    # The create key operation can be used to create any key type in Azure Key
    # Vault. If the named key already exists, Azure Key Vault creates a new version
    # of the key. It requires the keys/create permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name for the new key. The system will generate
    # the version name for the new key.
    # @param kty [JsonWebKeyType] The type of key to create. For valid values, see
    # JsonWebKeyType. Possible values include: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM',
    # 'oct'
    # @param key_size [Integer] The key size in bits. For example: 2048, 3072, or
    # 4096 for RSA.
    # @param key_ops [Array<JsonWebKeyOperation>]
    # @param key_attributes [KeyAttributes]
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param curve [JsonWebKeyCurveName] Elliptic curve name. For valid values, see
    # JsonWebKeyCurveName. Possible values include: 'P-256', 'P-384', 'P-521',
    # 'SECP256K1'
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_key_async(vault_base_url, key_name, kty, key_size:nil, key_ops:nil, key_attributes:nil, tags:nil, curve:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, "'key_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z-]+$'" if !key_name.nil? && key_name.match(Regexp.new('^^[0-9a-zA-Z-]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'kty is nil' if kty.nil?
      fail ArgumentError, "'kty' should satisfy the constraint - 'MinLength': '1'" if !kty.nil? && kty.length < 1

      parameters = KeyCreateParameters.new
      unless kty.nil? && key_size.nil? && key_ops.nil? && key_attributes.nil? && tags.nil? && curve.nil?
        parameters.kty = kty
        parameters.key_size = key_size
        parameters.key_ops = key_ops
        parameters.keyAttributes = key_attributes
        parameters.tags = tags
        parameters.curve = curve
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::KeyCreateParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'keys/{key-name}/create'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Imports an externally created key, stores it, and returns key parameters and
    # attributes to the client.
    #
    # The import key operation may be used to import any key type into an Azure Key
    # Vault. If the named key already exists, Azure Key Vault creates a new version
    # of the key. This operation requires the keys/import permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] Name for the imported key.
    # @param key [JsonWebKey] The Json web key
    # @param hsm [Boolean] Whether to import as a hardware key (HSM) or software
    # key.
    # @param key_attributes [KeyAttributes] The key management attributes.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyBundle] operation results.
    #
    def import_key(vault_base_url, key_name, key, hsm:nil, key_attributes:nil, tags:nil, custom_headers:nil)
      response = import_key_async(vault_base_url, key_name, key, hsm:hsm, key_attributes:key_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Imports an externally created key, stores it, and returns key parameters and
    # attributes to the client.
    #
    # The import key operation may be used to import any key type into an Azure Key
    # Vault. If the named key already exists, Azure Key Vault creates a new version
    # of the key. This operation requires the keys/import permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] Name for the imported key.
    # @param key [JsonWebKey] The Json web key
    # @param hsm [Boolean] Whether to import as a hardware key (HSM) or software
    # key.
    # @param key_attributes [KeyAttributes] The key management attributes.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def import_key_with_http_info(vault_base_url, key_name, key, hsm:nil, key_attributes:nil, tags:nil, custom_headers:nil)
      import_key_async(vault_base_url, key_name, key, hsm:hsm, key_attributes:key_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # Imports an externally created key, stores it, and returns key parameters and
    # attributes to the client.
    #
    # The import key operation may be used to import any key type into an Azure Key
    # Vault. If the named key already exists, Azure Key Vault creates a new version
    # of the key. This operation requires the keys/import permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] Name for the imported key.
    # @param key [JsonWebKey] The Json web key
    # @param hsm [Boolean] Whether to import as a hardware key (HSM) or software
    # key.
    # @param key_attributes [KeyAttributes] The key management attributes.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def import_key_async(vault_base_url, key_name, key, hsm:nil, key_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, "'key_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z-]+$'" if !key_name.nil? && key_name.match(Regexp.new('^^[0-9a-zA-Z-]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'key is nil' if key.nil?

      parameters = KeyImportParameters.new
      unless hsm.nil? && key.nil? && key_attributes.nil? && tags.nil?
        parameters.hsm = hsm
        parameters.key = key
        parameters.keyAttributes = key_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::KeyImportParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'keys/{key-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Deletes a key of any type from storage in Azure Key Vault.
    #
    # The delete key operation cannot be used to remove individual versions of a
    # key. This operation removes the cryptographic material associated with the
    # key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or
    # Encrypt/Decrypt operations. This operation requires the keys/delete
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key to delete.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedKeyBundle] operation results.
    #
    def delete_key(vault_base_url, key_name, custom_headers:nil)
      response = delete_key_async(vault_base_url, key_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a key of any type from storage in Azure Key Vault.
    #
    # The delete key operation cannot be used to remove individual versions of a
    # key. This operation removes the cryptographic material associated with the
    # key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or
    # Encrypt/Decrypt operations. This operation requires the keys/delete
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key to delete.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_key_with_http_info(vault_base_url, key_name, custom_headers:nil)
      delete_key_async(vault_base_url, key_name, custom_headers:custom_headers).value!
    end

    #
    # Deletes a key of any type from storage in Azure Key Vault.
    #
    # The delete key operation cannot be used to remove individual versions of a
    # key. This operation removes the cryptographic material associated with the
    # key, which means the key is not usable for Sign/Verify, Wrap/Unwrap or
    # Encrypt/Decrypt operations. This operation requires the keys/delete
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key to delete.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_key_async(vault_base_url, key_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'keys/{key-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedKeyBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # The update key operation changes specified attributes of a stored key and can
    # be applied to any key type and key version stored in Azure Key Vault.
    #
    # In order to perform this operation, the key must already exist in the Key
    # Vault. Note: The cryptographic material of a key itself cannot be changed.
    # This operation requires the keys/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of key to update.
    # @param key_version [String] The version of the key to update.
    # @param key_ops [Array<JsonWebKeyOperation>] Json web key operations. For more
    # information on possible key operations, see JsonWebKeyOperation.
    # @param key_attributes [KeyAttributes]
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyBundle] operation results.
    #
    def update_key(vault_base_url, key_name, key_version, key_ops:nil, key_attributes:nil, tags:nil, custom_headers:nil)
      response = update_key_async(vault_base_url, key_name, key_version, key_ops:key_ops, key_attributes:key_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # The update key operation changes specified attributes of a stored key and can
    # be applied to any key type and key version stored in Azure Key Vault.
    #
    # In order to perform this operation, the key must already exist in the Key
    # Vault. Note: The cryptographic material of a key itself cannot be changed.
    # This operation requires the keys/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of key to update.
    # @param key_version [String] The version of the key to update.
    # @param key_ops [Array<JsonWebKeyOperation>] Json web key operations. For more
    # information on possible key operations, see JsonWebKeyOperation.
    # @param key_attributes [KeyAttributes]
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def update_key_with_http_info(vault_base_url, key_name, key_version, key_ops:nil, key_attributes:nil, tags:nil, custom_headers:nil)
      update_key_async(vault_base_url, key_name, key_version, key_ops:key_ops, key_attributes:key_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # The update key operation changes specified attributes of a stored key and can
    # be applied to any key type and key version stored in Azure Key Vault.
    #
    # In order to perform this operation, the key must already exist in the Key
    # Vault. Note: The cryptographic material of a key itself cannot be changed.
    # This operation requires the keys/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of key to update.
    # @param key_version [String] The version of the key to update.
    # @param key_ops [Array<JsonWebKeyOperation>] Json web key operations. For more
    # information on possible key operations, see JsonWebKeyOperation.
    # @param key_attributes [KeyAttributes]
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_key_async(vault_base_url, key_name, key_version, key_ops:nil, key_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'key_version is nil' if key_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?

      parameters = KeyUpdateParameters.new
      unless key_ops.nil? && key_attributes.nil? && tags.nil?
        parameters.key_ops = key_ops
        parameters.keyAttributes = key_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::KeyUpdateParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'keys/{key-name}/{key-version}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name,'key-version' => key_version},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets the public part of a stored key.
    #
    # The get key operation is applicable to all key types. If the requested key is
    # symmetric, then no key material is released in the response. This operation
    # requires the keys/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key to get.
    # @param key_version [String] Adding the version parameter retrieves a specific
    # version of a key.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyBundle] operation results.
    #
    def get_key(vault_base_url, key_name, key_version, custom_headers:nil)
      response = get_key_async(vault_base_url, key_name, key_version, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets the public part of a stored key.
    #
    # The get key operation is applicable to all key types. If the requested key is
    # symmetric, then no key material is released in the response. This operation
    # requires the keys/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key to get.
    # @param key_version [String] Adding the version parameter retrieves a specific
    # version of a key.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_key_with_http_info(vault_base_url, key_name, key_version, custom_headers:nil)
      get_key_async(vault_base_url, key_name, key_version, custom_headers:custom_headers).value!
    end

    #
    # Gets the public part of a stored key.
    #
    # The get key operation is applicable to all key types. If the requested key is
    # symmetric, then no key material is released in the response. This operation
    # requires the keys/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key to get.
    # @param key_version [String] Adding the version parameter retrieves a specific
    # version of a key.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_key_async(vault_base_url, key_name, key_version, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'key_version is nil' if key_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'keys/{key-name}/{key-version}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name,'key-version' => key_version},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Retrieves a list of individual key versions with the same key name.
    #
    # The full key identifier, attributes, and tags are provided in the response.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<KeyItem>] operation results.
    #
    def get_key_versions(vault_base_url, key_name, maxresults:nil, custom_headers:nil)
      first_page = get_key_versions_as_lazy(vault_base_url, key_name, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # Retrieves a list of individual key versions with the same key name.
    #
    # The full key identifier, attributes, and tags are provided in the response.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_key_versions_with_http_info(vault_base_url, key_name, maxresults:nil, custom_headers:nil)
      get_key_versions_async(vault_base_url, key_name, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # Retrieves a list of individual key versions with the same key name.
    #
    # The full key identifier, attributes, and tags are provided in the response.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_key_versions_async(vault_base_url, key_name, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'keys/{key-name}/versions'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name},
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a stored key. The LIST operation is applicable to
    # all key types, however only the base key identifier, attributes, and tags are
    # provided in the response. Individual versions of a key are not listed in the
    # response. This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<KeyItem>] operation results.
    #
    def get_keys(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_keys_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a stored key. The LIST operation is applicable to
    # all key types, however only the base key identifier, attributes, and tags are
    # provided in the response. Individual versions of a key are not listed in the
    # response. This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_keys_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_keys_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a stored key. The LIST operation is applicable to
    # all key types, however only the base key identifier, attributes, and tags are
    # provided in the response. Individual versions of a key are not listed in the
    # response. This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_keys_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'keys'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Requests that a backup of the specified key be downloaded to the client.
    #
    # The Key Backup operation exports a key from Azure Key Vault in a protected
    # form. Note that this operation does NOT return key material in a form that
    # can be used outside the Azure Key Vault system, the returned key material is
    # either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The
    # intent of this operation is to allow a client to GENERATE a key in one Azure
    # Key Vault instance, BACKUP the key, and then RESTORE it into another Azure
    # Key Vault instance. The BACKUP operation may be used to export, in protected
    # form, any key type from Azure Key Vault. Individual versions of a key cannot
    # be backed up. BACKUP / RESTORE can be performed within geographical
    # boundaries only; meaning that a BACKUP from one geographical area cannot be
    # restored to another geographical area. For example, a backup from the US
    # geographical area cannot be restored in an EU geographical area. This
    # operation requires the key/backup permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [BackupKeyResult] operation results.
    #
    def backup_key(vault_base_url, key_name, custom_headers:nil)
      response = backup_key_async(vault_base_url, key_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Requests that a backup of the specified key be downloaded to the client.
    #
    # The Key Backup operation exports a key from Azure Key Vault in a protected
    # form. Note that this operation does NOT return key material in a form that
    # can be used outside the Azure Key Vault system, the returned key material is
    # either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The
    # intent of this operation is to allow a client to GENERATE a key in one Azure
    # Key Vault instance, BACKUP the key, and then RESTORE it into another Azure
    # Key Vault instance. The BACKUP operation may be used to export, in protected
    # form, any key type from Azure Key Vault. Individual versions of a key cannot
    # be backed up. BACKUP / RESTORE can be performed within geographical
    # boundaries only; meaning that a BACKUP from one geographical area cannot be
    # restored to another geographical area. For example, a backup from the US
    # geographical area cannot be restored in an EU geographical area. This
    # operation requires the key/backup permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def backup_key_with_http_info(vault_base_url, key_name, custom_headers:nil)
      backup_key_async(vault_base_url, key_name, custom_headers:custom_headers).value!
    end

    #
    # Requests that a backup of the specified key be downloaded to the client.
    #
    # The Key Backup operation exports a key from Azure Key Vault in a protected
    # form. Note that this operation does NOT return key material in a form that
    # can be used outside the Azure Key Vault system, the returned key material is
    # either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The
    # intent of this operation is to allow a client to GENERATE a key in one Azure
    # Key Vault instance, BACKUP the key, and then RESTORE it into another Azure
    # Key Vault instance. The BACKUP operation may be used to export, in protected
    # form, any key type from Azure Key Vault. Individual versions of a key cannot
    # be backed up. BACKUP / RESTORE can be performed within geographical
    # boundaries only; meaning that a BACKUP from one geographical area cannot be
    # restored to another geographical area. For example, a backup from the US
    # geographical area cannot be restored in an EU geographical area. This
    # operation requires the key/backup permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def backup_key_async(vault_base_url, key_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'keys/{key-name}/backup'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::BackupKeyResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Restores a backed up key to a vault.
    #
    # Imports a previously backed up key into Azure Key Vault, restoring the key,
    # its key identifier, attributes and access control policies. The RESTORE
    # operation may be used to import a previously backed up key. Individual
    # versions of a key cannot be restored. The key is restored in its entirety
    # with the same key name as it had when it was backed up. If the key name is
    # not available in the target Key Vault, the RESTORE operation will be
    # rejected. While the key name is retained during restore, the final key
    # identifier will change if the key is restored to a different vault. Restore
    # will restore all versions and preserve version identifiers. The RESTORE
    # operation is subject to security constraints: The target Key Vault must be
    # owned by the same Microsoft Azure Subscription as the source Key Vault The
    # user must have RESTORE permission in the target Key Vault. This operation
    # requires the keys/restore permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_bundle_backup The backup blob associated with a key bundle.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyBundle] operation results.
    #
    def restore_key(vault_base_url, key_bundle_backup, custom_headers:nil)
      response = restore_key_async(vault_base_url, key_bundle_backup, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Restores a backed up key to a vault.
    #
    # Imports a previously backed up key into Azure Key Vault, restoring the key,
    # its key identifier, attributes and access control policies. The RESTORE
    # operation may be used to import a previously backed up key. Individual
    # versions of a key cannot be restored. The key is restored in its entirety
    # with the same key name as it had when it was backed up. If the key name is
    # not available in the target Key Vault, the RESTORE operation will be
    # rejected. While the key name is retained during restore, the final key
    # identifier will change if the key is restored to a different vault. Restore
    # will restore all versions and preserve version identifiers. The RESTORE
    # operation is subject to security constraints: The target Key Vault must be
    # owned by the same Microsoft Azure Subscription as the source Key Vault The
    # user must have RESTORE permission in the target Key Vault. This operation
    # requires the keys/restore permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_bundle_backup The backup blob associated with a key bundle.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def restore_key_with_http_info(vault_base_url, key_bundle_backup, custom_headers:nil)
      restore_key_async(vault_base_url, key_bundle_backup, custom_headers:custom_headers).value!
    end

    #
    # Restores a backed up key to a vault.
    #
    # Imports a previously backed up key into Azure Key Vault, restoring the key,
    # its key identifier, attributes and access control policies. The RESTORE
    # operation may be used to import a previously backed up key. Individual
    # versions of a key cannot be restored. The key is restored in its entirety
    # with the same key name as it had when it was backed up. If the key name is
    # not available in the target Key Vault, the RESTORE operation will be
    # rejected. While the key name is retained during restore, the final key
    # identifier will change if the key is restored to a different vault. Restore
    # will restore all versions and preserve version identifiers. The RESTORE
    # operation is subject to security constraints: The target Key Vault must be
    # owned by the same Microsoft Azure Subscription as the source Key Vault The
    # user must have RESTORE permission in the target Key Vault. This operation
    # requires the keys/restore permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_bundle_backup The backup blob associated with a key bundle.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def restore_key_async(vault_base_url, key_bundle_backup, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'key_bundle_backup is nil' if key_bundle_backup.nil?

      parameters = KeyRestoreParameters.new
      unless key_bundle_backup.nil?
        parameters.keyBundleBackup = key_bundle_backup
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::KeyRestoreParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'keys/restore'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Encrypts an arbitrary sequence of bytes using an encryption key that is
    # stored in a key vault.
    #
    # The ENCRYPT operation encrypts an arbitrary sequence of bytes using an
    # encryption key that is stored in Azure Key Vault. Note that the ENCRYPT
    # operation only supports a single block of data, the size of which is
    # dependent on the target key and the encryption algorithm to be used. The
    # ENCRYPT operation is only strictly necessary for symmetric keys stored in
    # Azure Key Vault since protection with an asymmetric key can be performed
    # using public portion of the key. This operation is supported for asymmetric
    # keys as a convenience for callers that have a key-reference but do not have
    # access to the public key material. This operation requires the keys/encrypt
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyOperationResult] operation results.
    #
    def encrypt(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      response = encrypt_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Encrypts an arbitrary sequence of bytes using an encryption key that is
    # stored in a key vault.
    #
    # The ENCRYPT operation encrypts an arbitrary sequence of bytes using an
    # encryption key that is stored in Azure Key Vault. Note that the ENCRYPT
    # operation only supports a single block of data, the size of which is
    # dependent on the target key and the encryption algorithm to be used. The
    # ENCRYPT operation is only strictly necessary for symmetric keys stored in
    # Azure Key Vault since protection with an asymmetric key can be performed
    # using public portion of the key. This operation is supported for asymmetric
    # keys as a convenience for callers that have a key-reference but do not have
    # access to the public key material. This operation requires the keys/encrypt
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def encrypt_with_http_info(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      encrypt_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:custom_headers).value!
    end

    #
    # Encrypts an arbitrary sequence of bytes using an encryption key that is
    # stored in a key vault.
    #
    # The ENCRYPT operation encrypts an arbitrary sequence of bytes using an
    # encryption key that is stored in Azure Key Vault. Note that the ENCRYPT
    # operation only supports a single block of data, the size of which is
    # dependent on the target key and the encryption algorithm to be used. The
    # ENCRYPT operation is only strictly necessary for symmetric keys stored in
    # Azure Key Vault since protection with an asymmetric key can be performed
    # using public portion of the key. This operation is supported for asymmetric
    # keys as a convenience for callers that have a key-reference but do not have
    # access to the public key material. This operation requires the keys/encrypt
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def encrypt_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'key_version is nil' if key_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'algorithm is nil' if algorithm.nil?
      fail ArgumentError, "'algorithm' should satisfy the constraint - 'MinLength': '1'" if !algorithm.nil? && algorithm.length < 1
      fail ArgumentError, 'value is nil' if value.nil?

      parameters = KeyOperationsParameters.new
      unless algorithm.nil? && value.nil?
        parameters.algorithm = algorithm
        parameters.value = value
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::KeyOperationsParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'keys/{key-name}/{key-version}/encrypt'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name,'key-version' => key_version},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyOperationResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Decrypts a single block of encrypted data.
    #
    # The DECRYPT operation decrypts a well-formed block of ciphertext using the
    # target encryption key and specified algorithm. This operation is the reverse
    # of the ENCRYPT operation; only a single block of data may be decrypted, the
    # size of this block is dependent on the target key and the algorithm to be
    # used. The DECRYPT operation applies to asymmetric and symmetric keys stored
    # in Azure Key Vault since it uses the private portion of the key. This
    # operation requires the keys/decrypt permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyOperationResult] operation results.
    #
    def decrypt(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      response = decrypt_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Decrypts a single block of encrypted data.
    #
    # The DECRYPT operation decrypts a well-formed block of ciphertext using the
    # target encryption key and specified algorithm. This operation is the reverse
    # of the ENCRYPT operation; only a single block of data may be decrypted, the
    # size of this block is dependent on the target key and the algorithm to be
    # used. The DECRYPT operation applies to asymmetric and symmetric keys stored
    # in Azure Key Vault since it uses the private portion of the key. This
    # operation requires the keys/decrypt permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def decrypt_with_http_info(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      decrypt_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:custom_headers).value!
    end

    #
    # Decrypts a single block of encrypted data.
    #
    # The DECRYPT operation decrypts a well-formed block of ciphertext using the
    # target encryption key and specified algorithm. This operation is the reverse
    # of the ENCRYPT operation; only a single block of data may be decrypted, the
    # size of this block is dependent on the target key and the algorithm to be
    # used. The DECRYPT operation applies to asymmetric and symmetric keys stored
    # in Azure Key Vault since it uses the private portion of the key. This
    # operation requires the keys/decrypt permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def decrypt_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'key_version is nil' if key_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'algorithm is nil' if algorithm.nil?
      fail ArgumentError, "'algorithm' should satisfy the constraint - 'MinLength': '1'" if !algorithm.nil? && algorithm.length < 1
      fail ArgumentError, 'value is nil' if value.nil?

      parameters = KeyOperationsParameters.new
      unless algorithm.nil? && value.nil?
        parameters.algorithm = algorithm
        parameters.value = value
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::KeyOperationsParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'keys/{key-name}/{key-version}/decrypt'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name,'key-version' => key_version},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyOperationResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates a signature from a digest using the specified key.
    #
    # The SIGN operation is applicable to asymmetric and symmetric keys stored in
    # Azure Key Vault since this operation uses the private portion of the key.
    # This operation requires the keys/sign permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeySignatureAlgorithm] The signing/verification
    # algorithm identifier. For more information on possible algorithm types, see
    # JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',
    # 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512',
    # 'ECDSA256'
    # @param value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyOperationResult] operation results.
    #
    def sign(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      response = sign_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a signature from a digest using the specified key.
    #
    # The SIGN operation is applicable to asymmetric and symmetric keys stored in
    # Azure Key Vault since this operation uses the private portion of the key.
    # This operation requires the keys/sign permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeySignatureAlgorithm] The signing/verification
    # algorithm identifier. For more information on possible algorithm types, see
    # JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',
    # 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512',
    # 'ECDSA256'
    # @param value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def sign_with_http_info(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      sign_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:custom_headers).value!
    end

    #
    # Creates a signature from a digest using the specified key.
    #
    # The SIGN operation is applicable to asymmetric and symmetric keys stored in
    # Azure Key Vault since this operation uses the private portion of the key.
    # This operation requires the keys/sign permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeySignatureAlgorithm] The signing/verification
    # algorithm identifier. For more information on possible algorithm types, see
    # JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',
    # 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512',
    # 'ECDSA256'
    # @param value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def sign_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'key_version is nil' if key_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'algorithm is nil' if algorithm.nil?
      fail ArgumentError, "'algorithm' should satisfy the constraint - 'MinLength': '1'" if !algorithm.nil? && algorithm.length < 1
      fail ArgumentError, 'value is nil' if value.nil?

      parameters = KeySignParameters.new
      unless algorithm.nil? && value.nil?
        parameters.algorithm = algorithm
        parameters.value = value
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::KeySignParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'keys/{key-name}/{key-version}/sign'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name,'key-version' => key_version},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyOperationResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Verifies a signature using a specified key.
    #
    # The VERIFY operation is applicable to symmetric keys stored in Azure Key
    # Vault. VERIFY is not strictly necessary for asymmetric keys stored in Azure
    # Key Vault since signature verification can be performed using the public
    # portion of the key but this operation is supported as a convenience for
    # callers that only have a key-reference and not the public portion of the key.
    # This operation requires the keys/verify permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeySignatureAlgorithm] The signing/verification
    # algorithm. For more information on possible algorithm types, see
    # JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',
    # 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512',
    # 'ECDSA256'
    # @param digest The digest used for signing.
    # @param signature The signature to be verified.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyVerifyResult] operation results.
    #
    def verify(vault_base_url, key_name, key_version, algorithm, digest, signature, custom_headers:nil)
      response = verify_async(vault_base_url, key_name, key_version, algorithm, digest, signature, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Verifies a signature using a specified key.
    #
    # The VERIFY operation is applicable to symmetric keys stored in Azure Key
    # Vault. VERIFY is not strictly necessary for asymmetric keys stored in Azure
    # Key Vault since signature verification can be performed using the public
    # portion of the key but this operation is supported as a convenience for
    # callers that only have a key-reference and not the public portion of the key.
    # This operation requires the keys/verify permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeySignatureAlgorithm] The signing/verification
    # algorithm. For more information on possible algorithm types, see
    # JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',
    # 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512',
    # 'ECDSA256'
    # @param digest The digest used for signing.
    # @param signature The signature to be verified.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def verify_with_http_info(vault_base_url, key_name, key_version, algorithm, digest, signature, custom_headers:nil)
      verify_async(vault_base_url, key_name, key_version, algorithm, digest, signature, custom_headers:custom_headers).value!
    end

    #
    # Verifies a signature using a specified key.
    #
    # The VERIFY operation is applicable to symmetric keys stored in Azure Key
    # Vault. VERIFY is not strictly necessary for asymmetric keys stored in Azure
    # Key Vault since signature verification can be performed using the public
    # portion of the key but this operation is supported as a convenience for
    # callers that only have a key-reference and not the public portion of the key.
    # This operation requires the keys/verify permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeySignatureAlgorithm] The signing/verification
    # algorithm. For more information on possible algorithm types, see
    # JsonWebKeySignatureAlgorithm. Possible values include: 'PS256', 'PS384',
    # 'PS512', 'RS256', 'RS384', 'RS512', 'RSNULL', 'ES256', 'ES384', 'ES512',
    # 'ECDSA256'
    # @param digest The digest used for signing.
    # @param signature The signature to be verified.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def verify_async(vault_base_url, key_name, key_version, algorithm, digest, signature, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'key_version is nil' if key_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'algorithm is nil' if algorithm.nil?
      fail ArgumentError, "'algorithm' should satisfy the constraint - 'MinLength': '1'" if !algorithm.nil? && algorithm.length < 1
      fail ArgumentError, 'digest is nil' if digest.nil?
      fail ArgumentError, 'signature is nil' if signature.nil?

      parameters = KeyVerifyParameters.new
      unless algorithm.nil? && digest.nil? && signature.nil?
        parameters.algorithm = algorithm
        parameters.digest = digest
        parameters.signature = signature
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::KeyVerifyParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'keys/{key-name}/{key-version}/verify'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name,'key-version' => key_version},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyVerifyResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Wraps a symmetric key using a specified key.
    #
    # The WRAP operation supports encryption of a symmetric key using a key
    # encryption key that has previously been stored in an Azure Key Vault. The
    # WRAP operation is only strictly necessary for symmetric keys stored in Azure
    # Key Vault since protection with an asymmetric key can be performed using the
    # public portion of the key. This operation is supported for asymmetric keys as
    # a convenience for callers that have a key-reference but do not have access to
    # the public key material. This operation requires the keys/wrapKey permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyOperationResult] operation results.
    #
    def wrap_key(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      response = wrap_key_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Wraps a symmetric key using a specified key.
    #
    # The WRAP operation supports encryption of a symmetric key using a key
    # encryption key that has previously been stored in an Azure Key Vault. The
    # WRAP operation is only strictly necessary for symmetric keys stored in Azure
    # Key Vault since protection with an asymmetric key can be performed using the
    # public portion of the key. This operation is supported for asymmetric keys as
    # a convenience for callers that have a key-reference but do not have access to
    # the public key material. This operation requires the keys/wrapKey permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def wrap_key_with_http_info(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      wrap_key_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:custom_headers).value!
    end

    #
    # Wraps a symmetric key using a specified key.
    #
    # The WRAP operation supports encryption of a symmetric key using a key
    # encryption key that has previously been stored in an Azure Key Vault. The
    # WRAP operation is only strictly necessary for symmetric keys stored in Azure
    # Key Vault since protection with an asymmetric key can be performed using the
    # public portion of the key. This operation is supported for asymmetric keys as
    # a convenience for callers that have a key-reference but do not have access to
    # the public key material. This operation requires the keys/wrapKey permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def wrap_key_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'key_version is nil' if key_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'algorithm is nil' if algorithm.nil?
      fail ArgumentError, "'algorithm' should satisfy the constraint - 'MinLength': '1'" if !algorithm.nil? && algorithm.length < 1
      fail ArgumentError, 'value is nil' if value.nil?

      parameters = KeyOperationsParameters.new
      unless algorithm.nil? && value.nil?
        parameters.algorithm = algorithm
        parameters.value = value
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::KeyOperationsParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'keys/{key-name}/{key-version}/wrapkey'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name,'key-version' => key_version},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyOperationResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Unwraps a symmetric key using the specified key that was initially used for
    # wrapping that key.
    #
    # The UNWRAP operation supports decryption of a symmetric key using the target
    # key encryption key. This operation is the reverse of the WRAP operation. The
    # UNWRAP operation applies to asymmetric and symmetric keys stored in Azure Key
    # Vault since it uses the private portion of the key. This operation requires
    # the keys/unwrapKey permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyOperationResult] operation results.
    #
    def unwrap_key(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      response = unwrap_key_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Unwraps a symmetric key using the specified key that was initially used for
    # wrapping that key.
    #
    # The UNWRAP operation supports decryption of a symmetric key using the target
    # key encryption key. This operation is the reverse of the WRAP operation. The
    # UNWRAP operation applies to asymmetric and symmetric keys stored in Azure Key
    # Vault since it uses the private portion of the key. This operation requires
    # the keys/unwrapKey permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def unwrap_key_with_http_info(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      unwrap_key_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:custom_headers).value!
    end

    #
    # Unwraps a symmetric key using the specified key that was initially used for
    # wrapping that key.
    #
    # The UNWRAP operation supports decryption of a symmetric key using the target
    # key encryption key. This operation is the reverse of the WRAP operation. The
    # UNWRAP operation applies to asymmetric and symmetric keys stored in Azure Key
    # Vault since it uses the private portion of the key. This operation requires
    # the keys/unwrapKey permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param key_version [String] The version of the key.
    # @param algorithm [JsonWebKeyEncryptionAlgorithm] algorithm identifier.
    # Possible values include: 'RSA-OAEP', 'RSA-OAEP-256', 'RSA1_5'
    # @param value
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def unwrap_key_async(vault_base_url, key_name, key_version, algorithm, value, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'key_version is nil' if key_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'algorithm is nil' if algorithm.nil?
      fail ArgumentError, "'algorithm' should satisfy the constraint - 'MinLength': '1'" if !algorithm.nil? && algorithm.length < 1
      fail ArgumentError, 'value is nil' if value.nil?

      parameters = KeyOperationsParameters.new
      unless algorithm.nil? && value.nil?
        parameters.algorithm = algorithm
        parameters.value = value
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::KeyOperationsParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'keys/{key-name}/{key-version}/unwrapkey'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name,'key-version' => key_version},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyOperationResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the deleted keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a deleted key. This operation includes
    # deletion-specific information. The Get Deleted Keys operation is applicable
    # for vaults enabled for soft-delete. While the operation can be invoked on any
    # vault, it will return an error if invoked on a non soft-delete enabled vault.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<DeletedKeyItem>] operation results.
    #
    def get_deleted_keys(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_deleted_keys_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # Lists the deleted keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a deleted key. This operation includes
    # deletion-specific information. The Get Deleted Keys operation is applicable
    # for vaults enabled for soft-delete. While the operation can be invoked on any
    # vault, it will return an error if invoked on a non soft-delete enabled vault.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_keys_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_deleted_keys_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # Lists the deleted keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a deleted key. This operation includes
    # deletion-specific information. The Get Deleted Keys operation is applicable
    # for vaults enabled for soft-delete. While the operation can be invoked on any
    # vault, it will return an error if invoked on a non soft-delete enabled vault.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_keys_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedkeys'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedKeyListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets the public part of a deleted key.
    #
    # The Get Deleted Key operation is applicable for soft-delete enabled vaults.
    # While the operation can be invoked on any vault, it will return an error if
    # invoked on a non soft-delete enabled vault. This operation requires the
    # keys/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedKeyBundle] operation results.
    #
    def get_deleted_key(vault_base_url, key_name, custom_headers:nil)
      response = get_deleted_key_async(vault_base_url, key_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets the public part of a deleted key.
    #
    # The Get Deleted Key operation is applicable for soft-delete enabled vaults.
    # While the operation can be invoked on any vault, it will return an error if
    # invoked on a non soft-delete enabled vault. This operation requires the
    # keys/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_key_with_http_info(vault_base_url, key_name, custom_headers:nil)
      get_deleted_key_async(vault_base_url, key_name, custom_headers:custom_headers).value!
    end

    #
    # Gets the public part of a deleted key.
    #
    # The Get Deleted Key operation is applicable for soft-delete enabled vaults.
    # While the operation can be invoked on any vault, it will return an error if
    # invoked on a non soft-delete enabled vault. This operation requires the
    # keys/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_key_async(vault_base_url, key_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedkeys/{key-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedKeyBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Permanently deletes the specified key.
    #
    # The Purge Deleted Key operation is applicable for soft-delete enabled vaults.
    # While the operation can be invoked on any vault, it will return an error if
    # invoked on a non soft-delete enabled vault. This operation requires the
    # keys/purge permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def purge_deleted_key(vault_base_url, key_name, custom_headers:nil)
      response = purge_deleted_key_async(vault_base_url, key_name, custom_headers:custom_headers).value!
      nil
    end

    #
    # Permanently deletes the specified key.
    #
    # The Purge Deleted Key operation is applicable for soft-delete enabled vaults.
    # While the operation can be invoked on any vault, it will return an error if
    # invoked on a non soft-delete enabled vault. This operation requires the
    # keys/purge permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def purge_deleted_key_with_http_info(vault_base_url, key_name, custom_headers:nil)
      purge_deleted_key_async(vault_base_url, key_name, custom_headers:custom_headers).value!
    end

    #
    # Permanently deletes the specified key.
    #
    # The Purge Deleted Key operation is applicable for soft-delete enabled vaults.
    # While the operation can be invoked on any vault, it will return an error if
    # invoked on a non soft-delete enabled vault. This operation requires the
    # keys/purge permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def purge_deleted_key_async(vault_base_url, key_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedkeys/{key-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Recovers the deleted key to its latest version.
    #
    # The Recover Deleted Key operation is applicable for deleted keys in
    # soft-delete enabled vaults. It recovers the deleted key back to its latest
    # version under /keys. An attempt to recover an non-deleted key will return an
    # error. Consider this the inverse of the delete operation on soft-delete
    # enabled vaults. This operation requires the keys/recover permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the deleted key.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyBundle] operation results.
    #
    def recover_deleted_key(vault_base_url, key_name, custom_headers:nil)
      response = recover_deleted_key_async(vault_base_url, key_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Recovers the deleted key to its latest version.
    #
    # The Recover Deleted Key operation is applicable for deleted keys in
    # soft-delete enabled vaults. It recovers the deleted key back to its latest
    # version under /keys. An attempt to recover an non-deleted key will return an
    # error. Consider this the inverse of the delete operation on soft-delete
    # enabled vaults. This operation requires the keys/recover permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the deleted key.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def recover_deleted_key_with_http_info(vault_base_url, key_name, custom_headers:nil)
      recover_deleted_key_async(vault_base_url, key_name, custom_headers:custom_headers).value!
    end

    #
    # Recovers the deleted key to its latest version.
    #
    # The Recover Deleted Key operation is applicable for deleted keys in
    # soft-delete enabled vaults. It recovers the deleted key back to its latest
    # version under /keys. An attempt to recover an non-deleted key will return an
    # error. Consider this the inverse of the delete operation on soft-delete
    # enabled vaults. This operation requires the keys/recover permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the deleted key.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def recover_deleted_key_async(vault_base_url, key_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedkeys/{key-name}/recover'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Sets a secret in a specified key vault.
    #
    # The SET operation adds a secret to the Azure Key Vault. If the named secret
    # already exists, Azure Key Vault creates a new version of that secret. This
    # operation requires the secrets/set permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param value [String] The value of the secret.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param content_type [String] Type of the secret value such as a password.
    # @param secret_attributes [SecretAttributes] The secret management attributes.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SecretBundle] operation results.
    #
    def set_secret(vault_base_url, secret_name, value, tags:nil, content_type:nil, secret_attributes:nil, custom_headers:nil)
      response = set_secret_async(vault_base_url, secret_name, value, tags:tags, content_type:content_type, secret_attributes:secret_attributes, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Sets a secret in a specified key vault.
    #
    # The SET operation adds a secret to the Azure Key Vault. If the named secret
    # already exists, Azure Key Vault creates a new version of that secret. This
    # operation requires the secrets/set permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param value [String] The value of the secret.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param content_type [String] Type of the secret value such as a password.
    # @param secret_attributes [SecretAttributes] The secret management attributes.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def set_secret_with_http_info(vault_base_url, secret_name, value, tags:nil, content_type:nil, secret_attributes:nil, custom_headers:nil)
      set_secret_async(vault_base_url, secret_name, value, tags:tags, content_type:content_type, secret_attributes:secret_attributes, custom_headers:custom_headers).value!
    end

    #
    # Sets a secret in a specified key vault.
    #
    # The SET operation adds a secret to the Azure Key Vault. If the named secret
    # already exists, Azure Key Vault creates a new version of that secret. This
    # operation requires the secrets/set permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param value [String] The value of the secret.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param content_type [String] Type of the secret value such as a password.
    # @param secret_attributes [SecretAttributes] The secret management attributes.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def set_secret_async(vault_base_url, secret_name, value, tags:nil, content_type:nil, secret_attributes:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'secret_name is nil' if secret_name.nil?
      fail ArgumentError, "'secret_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z-]+$'" if !secret_name.nil? && secret_name.match(Regexp.new('^^[0-9a-zA-Z-]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'value is nil' if value.nil?

      parameters = SecretSetParameters.new
      unless value.nil? && tags.nil? && content_type.nil? && secret_attributes.nil?
        parameters.value = value
        parameters.tags = tags
        parameters.content_type = content_type
        parameters.secretAttributes = secret_attributes
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::SecretSetParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'secrets/{secret-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'secret-name' => secret_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Deletes a secret from a specified key vault.
    #
    # The DELETE operation applies to any secret stored in Azure Key Vault. DELETE
    # cannot be applied to an individual version of a secret. This operation
    # requires the secrets/delete permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedSecretBundle] operation results.
    #
    def delete_secret(vault_base_url, secret_name, custom_headers:nil)
      response = delete_secret_async(vault_base_url, secret_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a secret from a specified key vault.
    #
    # The DELETE operation applies to any secret stored in Azure Key Vault. DELETE
    # cannot be applied to an individual version of a secret. This operation
    # requires the secrets/delete permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_secret_with_http_info(vault_base_url, secret_name, custom_headers:nil)
      delete_secret_async(vault_base_url, secret_name, custom_headers:custom_headers).value!
    end

    #
    # Deletes a secret from a specified key vault.
    #
    # The DELETE operation applies to any secret stored in Azure Key Vault. DELETE
    # cannot be applied to an individual version of a secret. This operation
    # requires the secrets/delete permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_secret_async(vault_base_url, secret_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'secret_name is nil' if secret_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'secrets/{secret-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'secret-name' => secret_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedSecretBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates the attributes associated with a specified secret in a given key
    # vault.
    #
    # The UPDATE operation changes specified attributes of an existing stored
    # secret. Attributes that are not specified in the request are left unchanged.
    # The value of a secret itself cannot be changed. This operation requires the
    # secrets/set permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param secret_version [String] The version of the secret.
    # @param content_type [String] Type of the secret value such as a password.
    # @param secret_attributes [SecretAttributes] The secret management attributes.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SecretBundle] operation results.
    #
    def update_secret(vault_base_url, secret_name, secret_version, content_type:nil, secret_attributes:nil, tags:nil, custom_headers:nil)
      response = update_secret_async(vault_base_url, secret_name, secret_version, content_type:content_type, secret_attributes:secret_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates the attributes associated with a specified secret in a given key
    # vault.
    #
    # The UPDATE operation changes specified attributes of an existing stored
    # secret. Attributes that are not specified in the request are left unchanged.
    # The value of a secret itself cannot be changed. This operation requires the
    # secrets/set permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param secret_version [String] The version of the secret.
    # @param content_type [String] Type of the secret value such as a password.
    # @param secret_attributes [SecretAttributes] The secret management attributes.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def update_secret_with_http_info(vault_base_url, secret_name, secret_version, content_type:nil, secret_attributes:nil, tags:nil, custom_headers:nil)
      update_secret_async(vault_base_url, secret_name, secret_version, content_type:content_type, secret_attributes:secret_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # Updates the attributes associated with a specified secret in a given key
    # vault.
    #
    # The UPDATE operation changes specified attributes of an existing stored
    # secret. Attributes that are not specified in the request are left unchanged.
    # The value of a secret itself cannot be changed. This operation requires the
    # secrets/set permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param secret_version [String] The version of the secret.
    # @param content_type [String] Type of the secret value such as a password.
    # @param secret_attributes [SecretAttributes] The secret management attributes.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_secret_async(vault_base_url, secret_name, secret_version, content_type:nil, secret_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'secret_name is nil' if secret_name.nil?
      fail ArgumentError, 'secret_version is nil' if secret_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?

      parameters = SecretUpdateParameters.new
      unless content_type.nil? && secret_attributes.nil? && tags.nil?
        parameters.content_type = content_type
        parameters.secretAttributes = secret_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::SecretUpdateParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'secrets/{secret-name}/{secret-version}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'secret-name' => secret_name,'secret-version' => secret_version},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Get a specified secret from a given key vault.
    #
    # The GET operation is applicable to any secret stored in Azure Key Vault. This
    # operation requires the secrets/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param secret_version [String] The version of the secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SecretBundle] operation results.
    #
    def get_secret(vault_base_url, secret_name, secret_version, custom_headers:nil)
      response = get_secret_async(vault_base_url, secret_name, secret_version, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Get a specified secret from a given key vault.
    #
    # The GET operation is applicable to any secret stored in Azure Key Vault. This
    # operation requires the secrets/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param secret_version [String] The version of the secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_secret_with_http_info(vault_base_url, secret_name, secret_version, custom_headers:nil)
      get_secret_async(vault_base_url, secret_name, secret_version, custom_headers:custom_headers).value!
    end

    #
    # Get a specified secret from a given key vault.
    #
    # The GET operation is applicable to any secret stored in Azure Key Vault. This
    # operation requires the secrets/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param secret_version [String] The version of the secret.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_secret_async(vault_base_url, secret_name, secret_version, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'secret_name is nil' if secret_name.nil?
      fail ArgumentError, 'secret_version is nil' if secret_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'secrets/{secret-name}/{secret-version}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'secret-name' => secret_name,'secret-version' => secret_version},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List secrets in a specified key vault.
    #
    # The Get Secrets operation is applicable to the entire vault. However, only
    # the base secret identifier and its attributes are provided in the response.
    # Individual secret versions are not listed in the response. This operation
    # requires the secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<SecretItem>] operation results.
    #
    def get_secrets(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_secrets_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List secrets in a specified key vault.
    #
    # The Get Secrets operation is applicable to the entire vault. However, only
    # the base secret identifier and its attributes are provided in the response.
    # Individual secret versions are not listed in the response. This operation
    # requires the secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_secrets_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_secrets_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List secrets in a specified key vault.
    #
    # The Get Secrets operation is applicable to the entire vault. However, only
    # the base secret identifier and its attributes are provided in the response.
    # Individual secret versions are not listed in the response. This operation
    # requires the secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_secrets_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'secrets'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List all versions of the specified secret.
    #
    # The full secret identifier and attributes are provided in the response. No
    # values are returned for the secrets. This operations requires the
    # secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<SecretItem>] operation results.
    #
    def get_secret_versions(vault_base_url, secret_name, maxresults:nil, custom_headers:nil)
      first_page = get_secret_versions_as_lazy(vault_base_url, secret_name, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List all versions of the specified secret.
    #
    # The full secret identifier and attributes are provided in the response. No
    # values are returned for the secrets. This operations requires the
    # secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_secret_versions_with_http_info(vault_base_url, secret_name, maxresults:nil, custom_headers:nil)
      get_secret_versions_async(vault_base_url, secret_name, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List all versions of the specified secret.
    #
    # The full secret identifier and attributes are provided in the response. No
    # values are returned for the secrets. This operations requires the
    # secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_secret_versions_async(vault_base_url, secret_name, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'secret_name is nil' if secret_name.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'secrets/{secret-name}/versions'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'secret-name' => secret_name},
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists deleted secrets for the specified vault.
    #
    # The Get Deleted Secrets operation returns the secrets that have been deleted
    # for a vault enabled for soft-delete. This operation requires the secrets/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<DeletedSecretItem>] operation results.
    #
    def get_deleted_secrets(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_deleted_secrets_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # Lists deleted secrets for the specified vault.
    #
    # The Get Deleted Secrets operation returns the secrets that have been deleted
    # for a vault enabled for soft-delete. This operation requires the secrets/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_secrets_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_deleted_secrets_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # Lists deleted secrets for the specified vault.
    #
    # The Get Deleted Secrets operation returns the secrets that have been deleted
    # for a vault enabled for soft-delete. This operation requires the secrets/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_secrets_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedsecrets'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedSecretListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets the specified deleted secret.
    #
    # The Get Deleted Secret operation returns the specified deleted secret along
    # with its attributes. This operation requires the secrets/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedSecretBundle] operation results.
    #
    def get_deleted_secret(vault_base_url, secret_name, custom_headers:nil)
      response = get_deleted_secret_async(vault_base_url, secret_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets the specified deleted secret.
    #
    # The Get Deleted Secret operation returns the specified deleted secret along
    # with its attributes. This operation requires the secrets/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_secret_with_http_info(vault_base_url, secret_name, custom_headers:nil)
      get_deleted_secret_async(vault_base_url, secret_name, custom_headers:custom_headers).value!
    end

    #
    # Gets the specified deleted secret.
    #
    # The Get Deleted Secret operation returns the specified deleted secret along
    # with its attributes. This operation requires the secrets/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_secret_async(vault_base_url, secret_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'secret_name is nil' if secret_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedsecrets/{secret-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'secret-name' => secret_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedSecretBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Permanently deletes the specified secret.
    #
    # The purge deleted secret operation removes the secret permanently, without
    # the possibility of recovery. This operation can only be enabled on a
    # soft-delete enabled vault. This operation requires the secrets/purge
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def purge_deleted_secret(vault_base_url, secret_name, custom_headers:nil)
      response = purge_deleted_secret_async(vault_base_url, secret_name, custom_headers:custom_headers).value!
      nil
    end

    #
    # Permanently deletes the specified secret.
    #
    # The purge deleted secret operation removes the secret permanently, without
    # the possibility of recovery. This operation can only be enabled on a
    # soft-delete enabled vault. This operation requires the secrets/purge
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def purge_deleted_secret_with_http_info(vault_base_url, secret_name, custom_headers:nil)
      purge_deleted_secret_async(vault_base_url, secret_name, custom_headers:custom_headers).value!
    end

    #
    # Permanently deletes the specified secret.
    #
    # The purge deleted secret operation removes the secret permanently, without
    # the possibility of recovery. This operation can only be enabled on a
    # soft-delete enabled vault. This operation requires the secrets/purge
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def purge_deleted_secret_async(vault_base_url, secret_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'secret_name is nil' if secret_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedsecrets/{secret-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'secret-name' => secret_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Recovers the deleted secret to the latest version.
    #
    # Recovers the deleted secret in the specified vault. This operation can only
    # be performed on a soft-delete enabled vault. This operation requires the
    # secrets/recover permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the deleted secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SecretBundle] operation results.
    #
    def recover_deleted_secret(vault_base_url, secret_name, custom_headers:nil)
      response = recover_deleted_secret_async(vault_base_url, secret_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Recovers the deleted secret to the latest version.
    #
    # Recovers the deleted secret in the specified vault. This operation can only
    # be performed on a soft-delete enabled vault. This operation requires the
    # secrets/recover permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the deleted secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def recover_deleted_secret_with_http_info(vault_base_url, secret_name, custom_headers:nil)
      recover_deleted_secret_async(vault_base_url, secret_name, custom_headers:custom_headers).value!
    end

    #
    # Recovers the deleted secret to the latest version.
    #
    # Recovers the deleted secret in the specified vault. This operation can only
    # be performed on a soft-delete enabled vault. This operation requires the
    # secrets/recover permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the deleted secret.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def recover_deleted_secret_async(vault_base_url, secret_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'secret_name is nil' if secret_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedsecrets/{secret-name}/recover'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'secret-name' => secret_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Backs up the specified secret.
    #
    # Requests that a backup of the specified secret be downloaded to the client.
    # All versions of the secret will be downloaded. This operation requires the
    # secrets/backup permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [BackupSecretResult] operation results.
    #
    def backup_secret(vault_base_url, secret_name, custom_headers:nil)
      response = backup_secret_async(vault_base_url, secret_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Backs up the specified secret.
    #
    # Requests that a backup of the specified secret be downloaded to the client.
    # All versions of the secret will be downloaded. This operation requires the
    # secrets/backup permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def backup_secret_with_http_info(vault_base_url, secret_name, custom_headers:nil)
      backup_secret_async(vault_base_url, secret_name, custom_headers:custom_headers).value!
    end

    #
    # Backs up the specified secret.
    #
    # Requests that a backup of the specified secret be downloaded to the client.
    # All versions of the secret will be downloaded. This operation requires the
    # secrets/backup permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def backup_secret_async(vault_base_url, secret_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'secret_name is nil' if secret_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'secrets/{secret-name}/backup'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'secret-name' => secret_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::BackupSecretResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Restores a backed up secret to a vault.
    #
    # Restores a backed up secret, and all its versions, to a vault. This operation
    # requires the secrets/restore permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_bundle_backup The backup blob associated with a secret bundle.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SecretBundle] operation results.
    #
    def restore_secret(vault_base_url, secret_bundle_backup, custom_headers:nil)
      response = restore_secret_async(vault_base_url, secret_bundle_backup, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Restores a backed up secret to a vault.
    #
    # Restores a backed up secret, and all its versions, to a vault. This operation
    # requires the secrets/restore permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_bundle_backup The backup blob associated with a secret bundle.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def restore_secret_with_http_info(vault_base_url, secret_bundle_backup, custom_headers:nil)
      restore_secret_async(vault_base_url, secret_bundle_backup, custom_headers:custom_headers).value!
    end

    #
    # Restores a backed up secret to a vault.
    #
    # Restores a backed up secret, and all its versions, to a vault. This operation
    # requires the secrets/restore permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_bundle_backup The backup blob associated with a secret bundle.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def restore_secret_async(vault_base_url, secret_bundle_backup, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'secret_bundle_backup is nil' if secret_bundle_backup.nil?

      parameters = SecretRestoreParameters.new
      unless secret_bundle_backup.nil?
        parameters.secretBundleBackup = secret_bundle_backup
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::SecretRestoreParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'secrets/restore'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List certificates in a specified key vault
    #
    # The GetCertificates operation returns the set of certificates resources in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<CertificateItem>] operation results.
    #
    def get_certificates(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_certificates_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List certificates in a specified key vault
    #
    # The GetCertificates operation returns the set of certificates resources in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificates_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_certificates_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List certificates in a specified key vault
    #
    # The GetCertificates operation returns the set of certificates resources in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificates_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Deletes a certificate from a specified key vault.
    #
    # Deletes all versions of a certificate object along with its associated
    # policy. Delete certificate cannot be used to remove individual versions of a
    # certificate object. This operation requires the certificates/delete
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedCertificateBundle] operation results.
    #
    def delete_certificate(vault_base_url, certificate_name, custom_headers:nil)
      response = delete_certificate_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a certificate from a specified key vault.
    #
    # Deletes all versions of a certificate object along with its associated
    # policy. Delete certificate cannot be used to remove individual versions of a
    # certificate object. This operation requires the certificates/delete
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_certificate_with_http_info(vault_base_url, certificate_name, custom_headers:nil)
      delete_certificate_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
    end

    #
    # Deletes a certificate from a specified key vault.
    #
    # Deletes all versions of a certificate object along with its associated
    # policy. Delete certificate cannot be used to remove individual versions of a
    # certificate object. This operation requires the certificates/delete
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_certificate_async(vault_base_url, certificate_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/{certificate-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedCertificateBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Sets the certificate contacts for the specified key vault.
    #
    # Sets the certificate contacts for the specified key vault. This operation
    # requires the certificates/managecontacts permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param contacts [Contacts] The contacts for the key vault certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Contacts] operation results.
    #
    def set_certificate_contacts(vault_base_url, contacts, custom_headers:nil)
      response = set_certificate_contacts_async(vault_base_url, contacts, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Sets the certificate contacts for the specified key vault.
    #
    # Sets the certificate contacts for the specified key vault. This operation
    # requires the certificates/managecontacts permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param contacts [Contacts] The contacts for the key vault certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def set_certificate_contacts_with_http_info(vault_base_url, contacts, custom_headers:nil)
      set_certificate_contacts_async(vault_base_url, contacts, custom_headers:custom_headers).value!
    end

    #
    # Sets the certificate contacts for the specified key vault.
    #
    # Sets the certificate contacts for the specified key vault. This operation
    # requires the certificates/managecontacts permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param contacts [Contacts] The contacts for the key vault certificate.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def set_certificate_contacts_async(vault_base_url, contacts, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'contacts is nil' if contacts.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::Contacts.mapper()
      request_content = self.serialize(request_mapper,  contacts)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'certificates/contacts'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::Contacts.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the certificate contacts for a specified key vault.
    #
    # The GetCertificateContacts operation returns the set of certificate contact
    # resources in the specified key vault. This operation requires the
    # certificates/managecontacts permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Contacts] operation results.
    #
    def get_certificate_contacts(vault_base_url, custom_headers:nil)
      response = get_certificate_contacts_async(vault_base_url, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Lists the certificate contacts for a specified key vault.
    #
    # The GetCertificateContacts operation returns the set of certificate contact
    # resources in the specified key vault. This operation requires the
    # certificates/managecontacts permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_contacts_with_http_info(vault_base_url, custom_headers:nil)
      get_certificate_contacts_async(vault_base_url, custom_headers:custom_headers).value!
    end

    #
    # Lists the certificate contacts for a specified key vault.
    #
    # The GetCertificateContacts operation returns the set of certificate contact
    # resources in the specified key vault. This operation requires the
    # certificates/managecontacts permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_contacts_async(vault_base_url, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/contacts'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::Contacts.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Deletes the certificate contacts for a specified key vault.
    #
    # Deletes the certificate contacts for a specified key vault certificate. This
    # operation requires the certificates/managecontacts permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Contacts] operation results.
    #
    def delete_certificate_contacts(vault_base_url, custom_headers:nil)
      response = delete_certificate_contacts_async(vault_base_url, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes the certificate contacts for a specified key vault.
    #
    # Deletes the certificate contacts for a specified key vault certificate. This
    # operation requires the certificates/managecontacts permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_certificate_contacts_with_http_info(vault_base_url, custom_headers:nil)
      delete_certificate_contacts_async(vault_base_url, custom_headers:custom_headers).value!
    end

    #
    # Deletes the certificate contacts for a specified key vault.
    #
    # Deletes the certificate contacts for a specified key vault certificate. This
    # operation requires the certificates/managecontacts permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_certificate_contacts_async(vault_base_url, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/contacts'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::Contacts.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List certificate issuers for a specified key vault.
    #
    # The GetCertificateIssuers operation returns the set of certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<CertificateIssuerItem>] operation results.
    #
    def get_certificate_issuers(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_certificate_issuers_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List certificate issuers for a specified key vault.
    #
    # The GetCertificateIssuers operation returns the set of certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_issuers_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_certificate_issuers_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List certificate issuers for a specified key vault.
    #
    # The GetCertificateIssuers operation returns the set of certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_issuers_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/issuers'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateIssuerListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Sets the specified certificate issuer.
    #
    # The SetCertificateIssuer operation adds or updates the specified certificate
    # issuer. This operation requires the certificates/setissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param provider [String] The issuer provider.
    # @param credentials [IssuerCredentials] The credentials to be used for the
    # issuer.
    # @param organization_details [OrganizationDetails] Details of the organization
    # as provided to the issuer.
    # @param attributes [IssuerAttributes] Attributes of the issuer object.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [IssuerBundle] operation results.
    #
    def set_certificate_issuer(vault_base_url, issuer_name, provider, credentials:nil, organization_details:nil, attributes:nil, custom_headers:nil)
      response = set_certificate_issuer_async(vault_base_url, issuer_name, provider, credentials:credentials, organization_details:organization_details, attributes:attributes, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Sets the specified certificate issuer.
    #
    # The SetCertificateIssuer operation adds or updates the specified certificate
    # issuer. This operation requires the certificates/setissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param provider [String] The issuer provider.
    # @param credentials [IssuerCredentials] The credentials to be used for the
    # issuer.
    # @param organization_details [OrganizationDetails] Details of the organization
    # as provided to the issuer.
    # @param attributes [IssuerAttributes] Attributes of the issuer object.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def set_certificate_issuer_with_http_info(vault_base_url, issuer_name, provider, credentials:nil, organization_details:nil, attributes:nil, custom_headers:nil)
      set_certificate_issuer_async(vault_base_url, issuer_name, provider, credentials:credentials, organization_details:organization_details, attributes:attributes, custom_headers:custom_headers).value!
    end

    #
    # Sets the specified certificate issuer.
    #
    # The SetCertificateIssuer operation adds or updates the specified certificate
    # issuer. This operation requires the certificates/setissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param provider [String] The issuer provider.
    # @param credentials [IssuerCredentials] The credentials to be used for the
    # issuer.
    # @param organization_details [OrganizationDetails] Details of the organization
    # as provided to the issuer.
    # @param attributes [IssuerAttributes] Attributes of the issuer object.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def set_certificate_issuer_async(vault_base_url, issuer_name, provider, credentials:nil, organization_details:nil, attributes:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'issuer_name is nil' if issuer_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'provider is nil' if provider.nil?

      parameter = CertificateIssuerSetParameters.new
      unless provider.nil? && credentials.nil? && organization_details.nil? && attributes.nil?
        parameter.provider = provider
        parameter.credentials = credentials
        parameter.OrganizationDetails = organization_details
        parameter.attributes = attributes
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateIssuerSetParameters.mapper()
      request_content = self.serialize(request_mapper,  parameter)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'certificates/issuers/{issuer-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'issuer-name' => issuer_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::IssuerBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates the specified certificate issuer.
    #
    # The UpdateCertificateIssuer operation performs an update on the specified
    # certificate issuer entity. This operation requires the
    # certificates/setissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param provider [String] The issuer provider.
    # @param credentials [IssuerCredentials] The credentials to be used for the
    # issuer.
    # @param organization_details [OrganizationDetails] Details of the organization
    # as provided to the issuer.
    # @param attributes [IssuerAttributes] Attributes of the issuer object.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [IssuerBundle] operation results.
    #
    def update_certificate_issuer(vault_base_url, issuer_name, provider:nil, credentials:nil, organization_details:nil, attributes:nil, custom_headers:nil)
      response = update_certificate_issuer_async(vault_base_url, issuer_name, provider:provider, credentials:credentials, organization_details:organization_details, attributes:attributes, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates the specified certificate issuer.
    #
    # The UpdateCertificateIssuer operation performs an update on the specified
    # certificate issuer entity. This operation requires the
    # certificates/setissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param provider [String] The issuer provider.
    # @param credentials [IssuerCredentials] The credentials to be used for the
    # issuer.
    # @param organization_details [OrganizationDetails] Details of the organization
    # as provided to the issuer.
    # @param attributes [IssuerAttributes] Attributes of the issuer object.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def update_certificate_issuer_with_http_info(vault_base_url, issuer_name, provider:nil, credentials:nil, organization_details:nil, attributes:nil, custom_headers:nil)
      update_certificate_issuer_async(vault_base_url, issuer_name, provider:provider, credentials:credentials, organization_details:organization_details, attributes:attributes, custom_headers:custom_headers).value!
    end

    #
    # Updates the specified certificate issuer.
    #
    # The UpdateCertificateIssuer operation performs an update on the specified
    # certificate issuer entity. This operation requires the
    # certificates/setissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param provider [String] The issuer provider.
    # @param credentials [IssuerCredentials] The credentials to be used for the
    # issuer.
    # @param organization_details [OrganizationDetails] Details of the organization
    # as provided to the issuer.
    # @param attributes [IssuerAttributes] Attributes of the issuer object.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_certificate_issuer_async(vault_base_url, issuer_name, provider:nil, credentials:nil, organization_details:nil, attributes:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'issuer_name is nil' if issuer_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?

      parameter = CertificateIssuerUpdateParameters.new
      unless provider.nil? && credentials.nil? && organization_details.nil? && attributes.nil?
        parameter.provider = provider
        parameter.credentials = credentials
        parameter.OrganizationDetails = organization_details
        parameter.attributes = attributes
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateIssuerUpdateParameters.mapper()
      request_content = self.serialize(request_mapper,  parameter)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'certificates/issuers/{issuer-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'issuer-name' => issuer_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::IssuerBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the specified certificate issuer.
    #
    # The GetCertificateIssuer operation returns the specified certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [IssuerBundle] operation results.
    #
    def get_certificate_issuer(vault_base_url, issuer_name, custom_headers:nil)
      response = get_certificate_issuer_async(vault_base_url, issuer_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Lists the specified certificate issuer.
    #
    # The GetCertificateIssuer operation returns the specified certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_issuer_with_http_info(vault_base_url, issuer_name, custom_headers:nil)
      get_certificate_issuer_async(vault_base_url, issuer_name, custom_headers:custom_headers).value!
    end

    #
    # Lists the specified certificate issuer.
    #
    # The GetCertificateIssuer operation returns the specified certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_issuer_async(vault_base_url, issuer_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'issuer_name is nil' if issuer_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/issuers/{issuer-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'issuer-name' => issuer_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::IssuerBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Deletes the specified certificate issuer.
    #
    # The DeleteCertificateIssuer operation permanently removes the specified
    # certificate issuer from the vault. This operation requires the
    # certificates/manageissuers/deleteissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [IssuerBundle] operation results.
    #
    def delete_certificate_issuer(vault_base_url, issuer_name, custom_headers:nil)
      response = delete_certificate_issuer_async(vault_base_url, issuer_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes the specified certificate issuer.
    #
    # The DeleteCertificateIssuer operation permanently removes the specified
    # certificate issuer from the vault. This operation requires the
    # certificates/manageissuers/deleteissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_certificate_issuer_with_http_info(vault_base_url, issuer_name, custom_headers:nil)
      delete_certificate_issuer_async(vault_base_url, issuer_name, custom_headers:custom_headers).value!
    end

    #
    # Deletes the specified certificate issuer.
    #
    # The DeleteCertificateIssuer operation permanently removes the specified
    # certificate issuer from the vault. This operation requires the
    # certificates/manageissuers/deleteissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param issuer_name [String] The name of the issuer.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_certificate_issuer_async(vault_base_url, issuer_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'issuer_name is nil' if issuer_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/issuers/{issuer-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'issuer-name' => issuer_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::IssuerBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates a new certificate.
    #
    # If this is the first version, the certificate resource is created. This
    # operation requires the certificates/create permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param certificate_policy [CertificatePolicy] The management policy for the
    # certificate.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateOperation] operation results.
    #
    def create_certificate(vault_base_url, certificate_name, certificate_policy:nil, certificate_attributes:nil, tags:nil, custom_headers:nil)
      response = create_certificate_async(vault_base_url, certificate_name, certificate_policy:certificate_policy, certificate_attributes:certificate_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates a new certificate.
    #
    # If this is the first version, the certificate resource is created. This
    # operation requires the certificates/create permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param certificate_policy [CertificatePolicy] The management policy for the
    # certificate.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def create_certificate_with_http_info(vault_base_url, certificate_name, certificate_policy:nil, certificate_attributes:nil, tags:nil, custom_headers:nil)
      create_certificate_async(vault_base_url, certificate_name, certificate_policy:certificate_policy, certificate_attributes:certificate_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # Creates a new certificate.
    #
    # If this is the first version, the certificate resource is created. This
    # operation requires the certificates/create permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param certificate_policy [CertificatePolicy] The management policy for the
    # certificate.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_certificate_async(vault_base_url, certificate_name, certificate_policy:nil, certificate_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, "'certificate_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z-]+$'" if !certificate_name.nil? && certificate_name.match(Regexp.new('^^[0-9a-zA-Z-]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?

      parameters = CertificateCreateParameters.new
      unless certificate_policy.nil? && certificate_attributes.nil? && tags.nil?
        parameters.CertificatePolicy = certificate_policy
        parameters.CertificateAttributes = certificate_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateCreateParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'certificates/{certificate-name}/create'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 202
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 202
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateOperation.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Imports a certificate into a specified key vault.
    #
    # Imports an existing valid certificate, containing a private key, into Azure
    # Key Vault. The certificate to be imported can be in either PFX or PEM format.
    # If the certificate is in PEM format the PEM file must contain the key as well
    # as x509 certificates. This operation requires the certificates/import
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param base64encoded_certificate [String] Base64 encoded representation of
    # the certificate object to import. This certificate needs to contain the
    # private key.
    # @param password [String] If the private key in base64EncodedCertificate is
    # encrypted, the password used for encryption.
    # @param certificate_policy [CertificatePolicy] The management policy for the
    # certificate.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateBundle] operation results.
    #
    def import_certificate(vault_base_url, certificate_name, base64encoded_certificate, password:nil, certificate_policy:nil, certificate_attributes:nil, tags:nil, custom_headers:nil)
      response = import_certificate_async(vault_base_url, certificate_name, base64encoded_certificate, password:password, certificate_policy:certificate_policy, certificate_attributes:certificate_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Imports a certificate into a specified key vault.
    #
    # Imports an existing valid certificate, containing a private key, into Azure
    # Key Vault. The certificate to be imported can be in either PFX or PEM format.
    # If the certificate is in PEM format the PEM file must contain the key as well
    # as x509 certificates. This operation requires the certificates/import
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param base64encoded_certificate [String] Base64 encoded representation of
    # the certificate object to import. This certificate needs to contain the
    # private key.
    # @param password [String] If the private key in base64EncodedCertificate is
    # encrypted, the password used for encryption.
    # @param certificate_policy [CertificatePolicy] The management policy for the
    # certificate.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def import_certificate_with_http_info(vault_base_url, certificate_name, base64encoded_certificate, password:nil, certificate_policy:nil, certificate_attributes:nil, tags:nil, custom_headers:nil)
      import_certificate_async(vault_base_url, certificate_name, base64encoded_certificate, password:password, certificate_policy:certificate_policy, certificate_attributes:certificate_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # Imports a certificate into a specified key vault.
    #
    # Imports an existing valid certificate, containing a private key, into Azure
    # Key Vault. The certificate to be imported can be in either PFX or PEM format.
    # If the certificate is in PEM format the PEM file must contain the key as well
    # as x509 certificates. This operation requires the certificates/import
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param base64encoded_certificate [String] Base64 encoded representation of
    # the certificate object to import. This certificate needs to contain the
    # private key.
    # @param password [String] If the private key in base64EncodedCertificate is
    # encrypted, the password used for encryption.
    # @param certificate_policy [CertificatePolicy] The management policy for the
    # certificate.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def import_certificate_async(vault_base_url, certificate_name, base64encoded_certificate, password:nil, certificate_policy:nil, certificate_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, "'certificate_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z-]+$'" if !certificate_name.nil? && certificate_name.match(Regexp.new('^^[0-9a-zA-Z-]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'base64encoded_certificate is nil' if base64encoded_certificate.nil?

      parameters = CertificateImportParameters.new
      unless base64encoded_certificate.nil? && password.nil? && certificate_policy.nil? && certificate_attributes.nil? && tags.nil?
        parameters.base64EncodedCertificate = base64encoded_certificate
        parameters.password = password
        parameters.CertificatePolicy = certificate_policy
        parameters.CertificateAttributes = certificate_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateImportParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'certificates/{certificate-name}/import'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List the versions of a certificate.
    #
    # The GetCertificateVersions operation returns the versions of a certificate in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<CertificateItem>] operation results.
    #
    def get_certificate_versions(vault_base_url, certificate_name, maxresults:nil, custom_headers:nil)
      first_page = get_certificate_versions_as_lazy(vault_base_url, certificate_name, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List the versions of a certificate.
    #
    # The GetCertificateVersions operation returns the versions of a certificate in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_versions_with_http_info(vault_base_url, certificate_name, maxresults:nil, custom_headers:nil)
      get_certificate_versions_async(vault_base_url, certificate_name, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List the versions of a certificate.
    #
    # The GetCertificateVersions operation returns the versions of a certificate in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_versions_async(vault_base_url, certificate_name, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/{certificate-name}/versions'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the policy for a certificate.
    #
    # The GetCertificatePolicy operation returns the specified certificate policy
    # resources in the specified key vault. This operation requires the
    # certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in a given key
    # vault.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificatePolicy] operation results.
    #
    def get_certificate_policy(vault_base_url, certificate_name, custom_headers:nil)
      response = get_certificate_policy_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Lists the policy for a certificate.
    #
    # The GetCertificatePolicy operation returns the specified certificate policy
    # resources in the specified key vault. This operation requires the
    # certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in a given key
    # vault.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_policy_with_http_info(vault_base_url, certificate_name, custom_headers:nil)
      get_certificate_policy_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
    end

    #
    # Lists the policy for a certificate.
    #
    # The GetCertificatePolicy operation returns the specified certificate policy
    # resources in the specified key vault. This operation requires the
    # certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in a given key
    # vault.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_policy_async(vault_base_url, certificate_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/{certificate-name}/policy'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificatePolicy.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates the policy for a certificate.
    #
    # Set specified members in the certificate policy. Leave others as null. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in the given
    # vault.
    # @param certificate_policy [CertificatePolicy] The policy for the certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificatePolicy] operation results.
    #
    def update_certificate_policy(vault_base_url, certificate_name, certificate_policy, custom_headers:nil)
      response = update_certificate_policy_async(vault_base_url, certificate_name, certificate_policy, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates the policy for a certificate.
    #
    # Set specified members in the certificate policy. Leave others as null. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in the given
    # vault.
    # @param certificate_policy [CertificatePolicy] The policy for the certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def update_certificate_policy_with_http_info(vault_base_url, certificate_name, certificate_policy, custom_headers:nil)
      update_certificate_policy_async(vault_base_url, certificate_name, certificate_policy, custom_headers:custom_headers).value!
    end

    #
    # Updates the policy for a certificate.
    #
    # Set specified members in the certificate policy. Leave others as null. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in the given
    # vault.
    # @param certificate_policy [CertificatePolicy] The policy for the certificate.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_certificate_policy_async(vault_base_url, certificate_name, certificate_policy, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'certificate_policy is nil' if certificate_policy.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::CertificatePolicy.mapper()
      request_content = self.serialize(request_mapper,  certificate_policy)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'certificates/{certificate-name}/policy'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificatePolicy.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates the specified attributes associated with the given certificate.
    #
    # The UpdateCertificate operation applies the specified update on the given
    # certificate; the only elements updated are the certificate's attributes. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in the given key
    # vault.
    # @param certificate_version [String] The version of the certificate.
    # @param certificate_policy [CertificatePolicy] The management policy for the
    # certificate.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateBundle] operation results.
    #
    def update_certificate(vault_base_url, certificate_name, certificate_version, certificate_policy:nil, certificate_attributes:nil, tags:nil, custom_headers:nil)
      response = update_certificate_async(vault_base_url, certificate_name, certificate_version, certificate_policy:certificate_policy, certificate_attributes:certificate_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates the specified attributes associated with the given certificate.
    #
    # The UpdateCertificate operation applies the specified update on the given
    # certificate; the only elements updated are the certificate's attributes. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in the given key
    # vault.
    # @param certificate_version [String] The version of the certificate.
    # @param certificate_policy [CertificatePolicy] The management policy for the
    # certificate.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def update_certificate_with_http_info(vault_base_url, certificate_name, certificate_version, certificate_policy:nil, certificate_attributes:nil, tags:nil, custom_headers:nil)
      update_certificate_async(vault_base_url, certificate_name, certificate_version, certificate_policy:certificate_policy, certificate_attributes:certificate_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # Updates the specified attributes associated with the given certificate.
    #
    # The UpdateCertificate operation applies the specified update on the given
    # certificate; the only elements updated are the certificate's attributes. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in the given key
    # vault.
    # @param certificate_version [String] The version of the certificate.
    # @param certificate_policy [CertificatePolicy] The management policy for the
    # certificate.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_certificate_async(vault_base_url, certificate_name, certificate_version, certificate_policy:nil, certificate_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'certificate_version is nil' if certificate_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?

      parameters = CertificateUpdateParameters.new
      unless certificate_policy.nil? && certificate_attributes.nil? && tags.nil?
        parameters.CertificatePolicy = certificate_policy
        parameters.CertificateAttributes = certificate_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateUpdateParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'certificates/{certificate-name}/{certificate-version}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name,'certificate-version' => certificate_version},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets information about a certificate.
    #
    # Gets information about a specific certificate. This operation requires the
    # certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in the given
    # vault.
    # @param certificate_version [String] The version of the certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateBundle] operation results.
    #
    def get_certificate(vault_base_url, certificate_name, certificate_version, custom_headers:nil)
      response = get_certificate_async(vault_base_url, certificate_name, certificate_version, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets information about a certificate.
    #
    # Gets information about a specific certificate. This operation requires the
    # certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in the given
    # vault.
    # @param certificate_version [String] The version of the certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_with_http_info(vault_base_url, certificate_name, certificate_version, custom_headers:nil)
      get_certificate_async(vault_base_url, certificate_name, certificate_version, custom_headers:custom_headers).value!
    end

    #
    # Gets information about a certificate.
    #
    # Gets information about a specific certificate. This operation requires the
    # certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate in the given
    # vault.
    # @param certificate_version [String] The version of the certificate.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_async(vault_base_url, certificate_name, certificate_version, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'certificate_version is nil' if certificate_version.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/{certificate-name}/{certificate-version}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name,'certificate-version' => certificate_version},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates a certificate operation.
    #
    # Updates a certificate creation operation that is already in progress. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param cancellation_requested [Boolean] Indicates if cancellation was
    # requested on the certificate operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateOperation] operation results.
    #
    def update_certificate_operation(vault_base_url, certificate_name, cancellation_requested, custom_headers:nil)
      response = update_certificate_operation_async(vault_base_url, certificate_name, cancellation_requested, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates a certificate operation.
    #
    # Updates a certificate creation operation that is already in progress. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param cancellation_requested [Boolean] Indicates if cancellation was
    # requested on the certificate operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def update_certificate_operation_with_http_info(vault_base_url, certificate_name, cancellation_requested, custom_headers:nil)
      update_certificate_operation_async(vault_base_url, certificate_name, cancellation_requested, custom_headers:custom_headers).value!
    end

    #
    # Updates a certificate operation.
    #
    # Updates a certificate creation operation that is already in progress. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param cancellation_requested [Boolean] Indicates if cancellation was
    # requested on the certificate operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_certificate_operation_async(vault_base_url, certificate_name, cancellation_requested, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'cancellation_requested is nil' if cancellation_requested.nil?

      certificate_operation = CertificateOperationUpdateParameter.new
      unless cancellation_requested.nil?
        certificate_operation.cancellation_requested = cancellation_requested
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateOperationUpdateParameter.mapper()
      request_content = self.serialize(request_mapper,  certificate_operation)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'certificates/{certificate-name}/pending'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateOperation.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets the creation operation of a certificate.
    #
    # Gets the creation operation associated with a specified certificate. This
    # operation requires the certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateOperation] operation results.
    #
    def get_certificate_operation(vault_base_url, certificate_name, custom_headers:nil)
      response = get_certificate_operation_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets the creation operation of a certificate.
    #
    # Gets the creation operation associated with a specified certificate. This
    # operation requires the certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_operation_with_http_info(vault_base_url, certificate_name, custom_headers:nil)
      get_certificate_operation_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
    end

    #
    # Gets the creation operation of a certificate.
    #
    # Gets the creation operation associated with a specified certificate. This
    # operation requires the certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_operation_async(vault_base_url, certificate_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/{certificate-name}/pending'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateOperation.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Deletes the creation operation for a specific certificate.
    #
    # Deletes the creation operation for a specified certificate that is in the
    # process of being created. The certificate is no longer created. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateOperation] operation results.
    #
    def delete_certificate_operation(vault_base_url, certificate_name, custom_headers:nil)
      response = delete_certificate_operation_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes the creation operation for a specific certificate.
    #
    # Deletes the creation operation for a specified certificate that is in the
    # process of being created. The certificate is no longer created. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_certificate_operation_with_http_info(vault_base_url, certificate_name, custom_headers:nil)
      delete_certificate_operation_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
    end

    #
    # Deletes the creation operation for a specific certificate.
    #
    # Deletes the creation operation for a specified certificate that is in the
    # process of being created. The certificate is no longer created. This
    # operation requires the certificates/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_certificate_operation_async(vault_base_url, certificate_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'certificates/{certificate-name}/pending'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateOperation.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Merges a certificate or a certificate chain with a key pair existing on the
    # server.
    #
    # The MergeCertificate operation performs the merging of a certificate or
    # certificate chain with a key pair currently available in the service. This
    # operation requires the certificates/create permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param x509certificates [Array<Array<Integer>>] The certificate or the
    # certificate chain to merge.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateBundle] operation results.
    #
    def merge_certificate(vault_base_url, certificate_name, x509certificates, certificate_attributes:nil, tags:nil, custom_headers:nil)
      response = merge_certificate_async(vault_base_url, certificate_name, x509certificates, certificate_attributes:certificate_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Merges a certificate or a certificate chain with a key pair existing on the
    # server.
    #
    # The MergeCertificate operation performs the merging of a certificate or
    # certificate chain with a key pair currently available in the service. This
    # operation requires the certificates/create permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param x509certificates [Array<Array<Integer>>] The certificate or the
    # certificate chain to merge.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def merge_certificate_with_http_info(vault_base_url, certificate_name, x509certificates, certificate_attributes:nil, tags:nil, custom_headers:nil)
      merge_certificate_async(vault_base_url, certificate_name, x509certificates, certificate_attributes:certificate_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # Merges a certificate or a certificate chain with a key pair existing on the
    # server.
    #
    # The MergeCertificate operation performs the merging of a certificate or
    # certificate chain with a key pair currently available in the service. This
    # operation requires the certificates/create permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param x509certificates [Array<Array<Integer>>] The certificate or the
    # certificate chain to merge.
    # @param certificate_attributes [CertificateAttributes] The attributes of the
    # certificate (optional).
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def merge_certificate_async(vault_base_url, certificate_name, x509certificates, certificate_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'x509certificates is nil' if x509certificates.nil?

      parameters = CertificateMergeParameters.new
      unless x509certificates.nil? && certificate_attributes.nil? && tags.nil?
        parameters.x509Certificates = x509certificates
        parameters.CertificateAttributes = certificate_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateMergeParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'certificates/{certificate-name}/pending/merge'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 201
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 201
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the deleted certificates in the specified vault currently available for
    # recovery.
    #
    # The GetDeletedCertificates operation retrieves the certificates in the
    # current vault which are in a deleted state and ready for recovery or purging.
    # This operation includes deletion-specific information. This operation
    # requires the certificates/get/list permission. This operation can only be
    # enabled on soft-delete enabled vaults.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<DeletedCertificateItem>] operation results.
    #
    def get_deleted_certificates(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_deleted_certificates_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # Lists the deleted certificates in the specified vault currently available for
    # recovery.
    #
    # The GetDeletedCertificates operation retrieves the certificates in the
    # current vault which are in a deleted state and ready for recovery or purging.
    # This operation includes deletion-specific information. This operation
    # requires the certificates/get/list permission. This operation can only be
    # enabled on soft-delete enabled vaults.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_certificates_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_deleted_certificates_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # Lists the deleted certificates in the specified vault currently available for
    # recovery.
    #
    # The GetDeletedCertificates operation retrieves the certificates in the
    # current vault which are in a deleted state and ready for recovery or purging.
    # This operation includes deletion-specific information. This operation
    # requires the certificates/get/list permission. This operation can only be
    # enabled on soft-delete enabled vaults.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_certificates_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedcertificates'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedCertificateListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Retrieves information about the specified deleted certificate.
    #
    # The GetDeletedCertificate operation retrieves the deleted certificate
    # information plus its attributes, such as retention interval, scheduled
    # permanent deletion and the current deletion recovery level. This operation
    # requires the certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedCertificateBundle] operation results.
    #
    def get_deleted_certificate(vault_base_url, certificate_name, custom_headers:nil)
      response = get_deleted_certificate_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Retrieves information about the specified deleted certificate.
    #
    # The GetDeletedCertificate operation retrieves the deleted certificate
    # information plus its attributes, such as retention interval, scheduled
    # permanent deletion and the current deletion recovery level. This operation
    # requires the certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_certificate_with_http_info(vault_base_url, certificate_name, custom_headers:nil)
      get_deleted_certificate_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
    end

    #
    # Retrieves information about the specified deleted certificate.
    #
    # The GetDeletedCertificate operation retrieves the deleted certificate
    # information plus its attributes, such as retention interval, scheduled
    # permanent deletion and the current deletion recovery level. This operation
    # requires the certificates/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_certificate_async(vault_base_url, certificate_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedcertificates/{certificate-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedCertificateBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Permanently deletes the specified deleted certificate.
    #
    # The PurgeDeletedCertificate operation performs an irreversible deletion of
    # the specified certificate, without possibility for recovery. The operation is
    # not available if the recovery level does not specify 'Purgeable'. This
    # operation requires the certificate/purge permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def purge_deleted_certificate(vault_base_url, certificate_name, custom_headers:nil)
      response = purge_deleted_certificate_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
      nil
    end

    #
    # Permanently deletes the specified deleted certificate.
    #
    # The PurgeDeletedCertificate operation performs an irreversible deletion of
    # the specified certificate, without possibility for recovery. The operation is
    # not available if the recovery level does not specify 'Purgeable'. This
    # operation requires the certificate/purge permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def purge_deleted_certificate_with_http_info(vault_base_url, certificate_name, custom_headers:nil)
      purge_deleted_certificate_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
    end

    #
    # Permanently deletes the specified deleted certificate.
    #
    # The PurgeDeletedCertificate operation performs an irreversible deletion of
    # the specified certificate, without possibility for recovery. The operation is
    # not available if the recovery level does not specify 'Purgeable'. This
    # operation requires the certificate/purge permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def purge_deleted_certificate_async(vault_base_url, certificate_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedcertificates/{certificate-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 204
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?

        result
      end

      promise.execute
    end

    #
    # Recovers the deleted certificate back to its current version under
    # /certificates.
    #
    # The RecoverDeletedCertificate operation performs the reversal of the Delete
    # operation. The operation is applicable in vaults enabled for soft-delete, and
    # must be issued during the retention interval (available in the deleted
    # certificate's attributes). This operation requires the certificates/recover
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the deleted certificate
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateBundle] operation results.
    #
    def recover_deleted_certificate(vault_base_url, certificate_name, custom_headers:nil)
      response = recover_deleted_certificate_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Recovers the deleted certificate back to its current version under
    # /certificates.
    #
    # The RecoverDeletedCertificate operation performs the reversal of the Delete
    # operation. The operation is applicable in vaults enabled for soft-delete, and
    # must be issued during the retention interval (available in the deleted
    # certificate's attributes). This operation requires the certificates/recover
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the deleted certificate
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def recover_deleted_certificate_with_http_info(vault_base_url, certificate_name, custom_headers:nil)
      recover_deleted_certificate_async(vault_base_url, certificate_name, custom_headers:custom_headers).value!
    end

    #
    # Recovers the deleted certificate back to its current version under
    # /certificates.
    #
    # The RecoverDeletedCertificate operation performs the reversal of the Delete
    # operation. The operation is applicable in vaults enabled for soft-delete, and
    # must be issued during the retention interval (available in the deleted
    # certificate's attributes). This operation requires the certificates/recover
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the deleted certificate
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def recover_deleted_certificate_async(vault_base_url, certificate_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'deletedcertificates/{certificate-name}/recover'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List storage accounts managed by the specified key vault. This operation
    # requires the storage/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<StorageAccountItem>] operation results.
    #
    def get_storage_accounts(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_storage_accounts_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List storage accounts managed by the specified key vault. This operation
    # requires the storage/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_storage_accounts_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_storage_accounts_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List storage accounts managed by the specified key vault. This operation
    # requires the storage/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_storage_accounts_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'storage'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::StorageListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Deletes a storage account. This operation requires the storage/delete
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [StorageBundle] operation results.
    #
    def delete_storage_account(vault_base_url, storage_account_name, custom_headers:nil)
      response = delete_storage_account_async(vault_base_url, storage_account_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a storage account. This operation requires the storage/delete
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_storage_account_with_http_info(vault_base_url, storage_account_name, custom_headers:nil)
      delete_storage_account_async(vault_base_url, storage_account_name, custom_headers:custom_headers).value!
    end

    #
    # Deletes a storage account. This operation requires the storage/delete
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_storage_account_async(vault_base_url, storage_account_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'storage/{storage-account-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::StorageBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets information about a specified storage account. This operation requires
    # the storage/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [StorageBundle] operation results.
    #
    def get_storage_account(vault_base_url, storage_account_name, custom_headers:nil)
      response = get_storage_account_async(vault_base_url, storage_account_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets information about a specified storage account. This operation requires
    # the storage/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_storage_account_with_http_info(vault_base_url, storage_account_name, custom_headers:nil)
      get_storage_account_async(vault_base_url, storage_account_name, custom_headers:custom_headers).value!
    end

    #
    # Gets information about a specified storage account. This operation requires
    # the storage/get permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_storage_account_async(vault_base_url, storage_account_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'storage/{storage-account-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::StorageBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates or updates a new storage account. This operation requires the
    # storage/set permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param resource_id [String] Storage account resource id.
    # @param active_key_name [String] Current active storage account key name.
    # @param auto_regenerate_key [Boolean] whether keyvault should manage the
    # storage account for the user.
    # @param regeneration_period [String] The key regeneration time duration
    # specified in ISO-8601 format.
    # @param storage_account_attributes [StorageAccountAttributes] The attributes
    # of the storage account.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [StorageBundle] operation results.
    #
    def set_storage_account(vault_base_url, storage_account_name, resource_id, active_key_name, auto_regenerate_key, regeneration_period:nil, storage_account_attributes:nil, tags:nil, custom_headers:nil)
      response = set_storage_account_async(vault_base_url, storage_account_name, resource_id, active_key_name, auto_regenerate_key, regeneration_period:regeneration_period, storage_account_attributes:storage_account_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates or updates a new storage account. This operation requires the
    # storage/set permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param resource_id [String] Storage account resource id.
    # @param active_key_name [String] Current active storage account key name.
    # @param auto_regenerate_key [Boolean] whether keyvault should manage the
    # storage account for the user.
    # @param regeneration_period [String] The key regeneration time duration
    # specified in ISO-8601 format.
    # @param storage_account_attributes [StorageAccountAttributes] The attributes
    # of the storage account.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def set_storage_account_with_http_info(vault_base_url, storage_account_name, resource_id, active_key_name, auto_regenerate_key, regeneration_period:nil, storage_account_attributes:nil, tags:nil, custom_headers:nil)
      set_storage_account_async(vault_base_url, storage_account_name, resource_id, active_key_name, auto_regenerate_key, regeneration_period:regeneration_period, storage_account_attributes:storage_account_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # Creates or updates a new storage account. This operation requires the
    # storage/set permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param resource_id [String] Storage account resource id.
    # @param active_key_name [String] Current active storage account key name.
    # @param auto_regenerate_key [Boolean] whether keyvault should manage the
    # storage account for the user.
    # @param regeneration_period [String] The key regeneration time duration
    # specified in ISO-8601 format.
    # @param storage_account_attributes [StorageAccountAttributes] The attributes
    # of the storage account.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def set_storage_account_async(vault_base_url, storage_account_name, resource_id, active_key_name, auto_regenerate_key, regeneration_period:nil, storage_account_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'resource_id is nil' if resource_id.nil?
      fail ArgumentError, 'active_key_name is nil' if active_key_name.nil?
      fail ArgumentError, 'auto_regenerate_key is nil' if auto_regenerate_key.nil?

      parameters = StorageAccountCreateParameters.new
      unless resource_id.nil? && active_key_name.nil? && auto_regenerate_key.nil? && regeneration_period.nil? && storage_account_attributes.nil? && tags.nil?
        parameters.resource_id = resource_id
        parameters.active_key_name = active_key_name
        parameters.auto_regenerate_key = auto_regenerate_key
        parameters.regeneration_period = regeneration_period
        parameters.StorageAccountAttributes = storage_account_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::StorageAccountCreateParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'storage/{storage-account-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::StorageBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates the specified attributes associated with the given storage account.
    # This operation requires the storage/set/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param active_key_name [String] The current active storage account key name.
    # @param auto_regenerate_key [Boolean] whether keyvault should manage the
    # storage account for the user.
    # @param regeneration_period [String] The key regeneration time duration
    # specified in ISO-8601 format.
    # @param storage_account_attributes [StorageAccountAttributes] The attributes
    # of the storage account.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [StorageBundle] operation results.
    #
    def update_storage_account(vault_base_url, storage_account_name, active_key_name:nil, auto_regenerate_key:nil, regeneration_period:nil, storage_account_attributes:nil, tags:nil, custom_headers:nil)
      response = update_storage_account_async(vault_base_url, storage_account_name, active_key_name:active_key_name, auto_regenerate_key:auto_regenerate_key, regeneration_period:regeneration_period, storage_account_attributes:storage_account_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates the specified attributes associated with the given storage account.
    # This operation requires the storage/set/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param active_key_name [String] The current active storage account key name.
    # @param auto_regenerate_key [Boolean] whether keyvault should manage the
    # storage account for the user.
    # @param regeneration_period [String] The key regeneration time duration
    # specified in ISO-8601 format.
    # @param storage_account_attributes [StorageAccountAttributes] The attributes
    # of the storage account.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def update_storage_account_with_http_info(vault_base_url, storage_account_name, active_key_name:nil, auto_regenerate_key:nil, regeneration_period:nil, storage_account_attributes:nil, tags:nil, custom_headers:nil)
      update_storage_account_async(vault_base_url, storage_account_name, active_key_name:active_key_name, auto_regenerate_key:auto_regenerate_key, regeneration_period:regeneration_period, storage_account_attributes:storage_account_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # Updates the specified attributes associated with the given storage account.
    # This operation requires the storage/set/update permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param active_key_name [String] The current active storage account key name.
    # @param auto_regenerate_key [Boolean] whether keyvault should manage the
    # storage account for the user.
    # @param regeneration_period [String] The key regeneration time duration
    # specified in ISO-8601 format.
    # @param storage_account_attributes [StorageAccountAttributes] The attributes
    # of the storage account.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_storage_account_async(vault_base_url, storage_account_name, active_key_name:nil, auto_regenerate_key:nil, regeneration_period:nil, storage_account_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?

      parameters = StorageAccountUpdateParameters.new
      unless active_key_name.nil? && auto_regenerate_key.nil? && regeneration_period.nil? && storage_account_attributes.nil? && tags.nil?
        parameters.active_key_name = active_key_name
        parameters.auto_regenerate_key = auto_regenerate_key
        parameters.regeneration_period = regeneration_period
        parameters.StorageAccountAttributes = storage_account_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::StorageAccountUpdateParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'storage/{storage-account-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::StorageBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Regenerates the specified key value for the given storage account. This
    # operation requires the storage/regeneratekey permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param key_name [String] The storage account key name.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [StorageBundle] operation results.
    #
    def regenerate_storage_account_key(vault_base_url, storage_account_name, key_name, custom_headers:nil)
      response = regenerate_storage_account_key_async(vault_base_url, storage_account_name, key_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Regenerates the specified key value for the given storage account. This
    # operation requires the storage/regeneratekey permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param key_name [String] The storage account key name.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def regenerate_storage_account_key_with_http_info(vault_base_url, storage_account_name, key_name, custom_headers:nil)
      regenerate_storage_account_key_async(vault_base_url, storage_account_name, key_name, custom_headers:custom_headers).value!
    end

    #
    # Regenerates the specified key value for the given storage account. This
    # operation requires the storage/regeneratekey permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param key_name [String] The storage account key name.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def regenerate_storage_account_key_async(vault_base_url, storage_account_name, key_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?

      parameters = StorageAccountRegenerteKeyParameters.new
      unless key_name.nil?
        parameters.key_name = key_name
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::StorageAccountRegenerteKeyParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'storage/{storage-account-name}/regeneratekey'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::StorageBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List storage SAS definitions for the given storage account. This operation
    # requires the storage/listsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array<SasDefinitionItem>] operation results.
    #
    def get_sas_definitions(vault_base_url, storage_account_name, maxresults:nil, custom_headers:nil)
      first_page = get_sas_definitions_as_lazy(vault_base_url, storage_account_name, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List storage SAS definitions for the given storage account. This operation
    # requires the storage/listsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_sas_definitions_with_http_info(vault_base_url, storage_account_name, maxresults:nil, custom_headers:nil)
      get_sas_definitions_async(vault_base_url, storage_account_name, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List storage SAS definitions for the given storage account. This operation
    # requires the storage/listsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_sas_definitions_async(vault_base_url, storage_account_name, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'storage/{storage-account-name}/sas'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name},
          query_params: {'maxresults' => maxresults,'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SasDefinitionListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Deletes a SAS definition from a specified storage account. This operation
    # requires the storage/deletesas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SasDefinitionBundle] operation results.
    #
    def delete_sas_definition(vault_base_url, storage_account_name, sas_definition_name, custom_headers:nil)
      response = delete_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Deletes a SAS definition from a specified storage account. This operation
    # requires the storage/deletesas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def delete_sas_definition_with_http_info(vault_base_url, storage_account_name, sas_definition_name, custom_headers:nil)
      delete_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, custom_headers:custom_headers).value!
    end

    #
    # Deletes a SAS definition from a specified storage account. This operation
    # requires the storage/deletesas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'sas_definition_name is nil' if sas_definition_name.nil?
      fail ArgumentError, "'sas_definition_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !sas_definition_name.nil? && sas_definition_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'storage/{storage-account-name}/sas/{sas-definition-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name,'sas-definition-name' => sas_definition_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SasDefinitionBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Gets information about a SAS definition for the specified storage account.
    # This operation requires the storage/getsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SasDefinitionBundle] operation results.
    #
    def get_sas_definition(vault_base_url, storage_account_name, sas_definition_name, custom_headers:nil)
      response = get_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Gets information about a SAS definition for the specified storage account.
    # This operation requires the storage/getsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_sas_definition_with_http_info(vault_base_url, storage_account_name, sas_definition_name, custom_headers:nil)
      get_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, custom_headers:custom_headers).value!
    end

    #
    # Gets information about a SAS definition for the specified storage account.
    # This operation requires the storage/getsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'sas_definition_name is nil' if sas_definition_name.nil?
      fail ArgumentError, "'sas_definition_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !sas_definition_name.nil? && sas_definition_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = 'storage/{storage-account-name}/sas/{sas-definition-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name,'sas-definition-name' => sas_definition_name},
          query_params: {'api-version' => api_version},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SasDefinitionBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Creates or updates a new SAS definition for the specified storage account.
    # This operation requires the storage/setsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param parameters [Hash{String => String}] Sas definition creation metadata
    # in the form of key-value pairs.
    # @param sas_definition_attributes [SasDefinitionAttributes] The attributes of
    # the SAS definition.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SasDefinitionBundle] operation results.
    #
    def set_sas_definition(vault_base_url, storage_account_name, sas_definition_name, parameters, sas_definition_attributes:nil, tags:nil, custom_headers:nil)
      response = set_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, parameters, sas_definition_attributes:sas_definition_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Creates or updates a new SAS definition for the specified storage account.
    # This operation requires the storage/setsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param parameters [Hash{String => String}] Sas definition creation metadata
    # in the form of key-value pairs.
    # @param sas_definition_attributes [SasDefinitionAttributes] The attributes of
    # the SAS definition.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def set_sas_definition_with_http_info(vault_base_url, storage_account_name, sas_definition_name, parameters, sas_definition_attributes:nil, tags:nil, custom_headers:nil)
      set_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, parameters, sas_definition_attributes:sas_definition_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # Creates or updates a new SAS definition for the specified storage account.
    # This operation requires the storage/setsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param parameters [Hash{String => String}] Sas definition creation metadata
    # in the form of key-value pairs.
    # @param sas_definition_attributes [SasDefinitionAttributes] The attributes of
    # the SAS definition.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def set_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, parameters, sas_definition_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'sas_definition_name is nil' if sas_definition_name.nil?
      fail ArgumentError, "'sas_definition_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !sas_definition_name.nil? && sas_definition_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?
      fail ArgumentError, 'parameters is nil' if parameters.nil?

      parameters = SasDefinitionCreateParameters.new
      unless parameters.nil? && sas_definition_attributes.nil? && tags.nil?
        parameters.parameters = parameters
        parameters.SasDefinitionAttributes = sas_definition_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::SasDefinitionCreateParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'storage/{storage-account-name}/sas/{sas-definition-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name,'sas-definition-name' => sas_definition_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SasDefinitionBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Updates the specified attributes associated with the given SAS definition.
    # This operation requires the storage/setsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param parameters [Hash{String => String}] Sas definition update metadata in
    # the form of key-value pairs.
    # @param sas_definition_attributes [SasDefinitionAttributes] The attributes of
    # the SAS definition.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SasDefinitionBundle] operation results.
    #
    def update_sas_definition(vault_base_url, storage_account_name, sas_definition_name, parameters:nil, sas_definition_attributes:nil, tags:nil, custom_headers:nil)
      response = update_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, parameters:parameters, sas_definition_attributes:sas_definition_attributes, tags:tags, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Updates the specified attributes associated with the given SAS definition.
    # This operation requires the storage/setsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param parameters [Hash{String => String}] Sas definition update metadata in
    # the form of key-value pairs.
    # @param sas_definition_attributes [SasDefinitionAttributes] The attributes of
    # the SAS definition.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def update_sas_definition_with_http_info(vault_base_url, storage_account_name, sas_definition_name, parameters:nil, sas_definition_attributes:nil, tags:nil, custom_headers:nil)
      update_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, parameters:parameters, sas_definition_attributes:sas_definition_attributes, tags:tags, custom_headers:custom_headers).value!
    end

    #
    # Updates the specified attributes associated with the given SAS definition.
    # This operation requires the storage/setsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param sas_definition_name [String] The name of the SAS definition.
    # @param parameters [Hash{String => String}] Sas definition update metadata in
    # the form of key-value pairs.
    # @param sas_definition_attributes [SasDefinitionAttributes] The attributes of
    # the SAS definition.
    # @param tags [Hash{String => String}] Application specific metadata in the
    # form of key-value pairs.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_sas_definition_async(vault_base_url, storage_account_name, sas_definition_name, parameters:nil, sas_definition_attributes:nil, tags:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'sas_definition_name is nil' if sas_definition_name.nil?
      fail ArgumentError, "'sas_definition_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !sas_definition_name.nil? && sas_definition_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, 'api_version is nil' if api_version.nil?

      parameters = SasDefinitionUpdateParameters.new
      unless parameters.nil? && sas_definition_attributes.nil? && tags.nil?
        parameters.parameters = parameters
        parameters.SasDefinitionAttributes = sas_definition_attributes
        parameters.tags = tags
      end

      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?

      # Serialize Request
      request_mapper = Azure::KeyVault::V2016_10_01::Models::SasDefinitionUpdateParameters.mapper()
      request_content = self.serialize(request_mapper,  parameters)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'storage/{storage-account-name}/sas/{sas-definition-name}'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name,'sas-definition-name' => sas_definition_name},
          query_params: {'api-version' => api_version},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SasDefinitionBundle.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Retrieves a list of individual key versions with the same key name.
    #
    # The full key identifier, attributes, and tags are provided in the response.
    # This operation requires the keys/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyListResult] operation results.
    #
    def get_key_versions_next(next_page_link, custom_headers:nil)
      response = get_key_versions_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Retrieves a list of individual key versions with the same key name.
    #
    # The full key identifier, attributes, and tags are provided in the response.
    # This operation requires the keys/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_key_versions_next_with_http_info(next_page_link, custom_headers:nil)
      get_key_versions_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # Retrieves a list of individual key versions with the same key name.
    #
    # The full key identifier, attributes, and tags are provided in the response.
    # This operation requires the keys/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_key_versions_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a stored key. The LIST operation is applicable to
    # all key types, however only the base key identifier, attributes, and tags are
    # provided in the response. Individual versions of a key are not listed in the
    # response. This operation requires the keys/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyListResult] operation results.
    #
    def get_keys_next(next_page_link, custom_headers:nil)
      response = get_keys_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a stored key. The LIST operation is applicable to
    # all key types, however only the base key identifier, attributes, and tags are
    # provided in the response. Individual versions of a key are not listed in the
    # response. This operation requires the keys/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_keys_next_with_http_info(next_page_link, custom_headers:nil)
      get_keys_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # List keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a stored key. The LIST operation is applicable to
    # all key types, however only the base key identifier, attributes, and tags are
    # provided in the response. Individual versions of a key are not listed in the
    # response. This operation requires the keys/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_keys_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the deleted keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a deleted key. This operation includes
    # deletion-specific information. The Get Deleted Keys operation is applicable
    # for vaults enabled for soft-delete. While the operation can be invoked on any
    # vault, it will return an error if invoked on a non soft-delete enabled vault.
    # This operation requires the keys/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedKeyListResult] operation results.
    #
    def get_deleted_keys_next(next_page_link, custom_headers:nil)
      response = get_deleted_keys_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Lists the deleted keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a deleted key. This operation includes
    # deletion-specific information. The Get Deleted Keys operation is applicable
    # for vaults enabled for soft-delete. While the operation can be invoked on any
    # vault, it will return an error if invoked on a non soft-delete enabled vault.
    # This operation requires the keys/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_keys_next_with_http_info(next_page_link, custom_headers:nil)
      get_deleted_keys_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # Lists the deleted keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a deleted key. This operation includes
    # deletion-specific information. The Get Deleted Keys operation is applicable
    # for vaults enabled for soft-delete. While the operation can be invoked on any
    # vault, it will return an error if invoked on a non soft-delete enabled vault.
    # This operation requires the keys/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_keys_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedKeyListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List secrets in a specified key vault.
    #
    # The Get Secrets operation is applicable to the entire vault. However, only
    # the base secret identifier and its attributes are provided in the response.
    # Individual secret versions are not listed in the response. This operation
    # requires the secrets/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SecretListResult] operation results.
    #
    def get_secrets_next(next_page_link, custom_headers:nil)
      response = get_secrets_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List secrets in a specified key vault.
    #
    # The Get Secrets operation is applicable to the entire vault. However, only
    # the base secret identifier and its attributes are provided in the response.
    # Individual secret versions are not listed in the response. This operation
    # requires the secrets/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_secrets_next_with_http_info(next_page_link, custom_headers:nil)
      get_secrets_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # List secrets in a specified key vault.
    #
    # The Get Secrets operation is applicable to the entire vault. However, only
    # the base secret identifier and its attributes are provided in the response.
    # Individual secret versions are not listed in the response. This operation
    # requires the secrets/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_secrets_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List all versions of the specified secret.
    #
    # The full secret identifier and attributes are provided in the response. No
    # values are returned for the secrets. This operations requires the
    # secrets/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SecretListResult] operation results.
    #
    def get_secret_versions_next(next_page_link, custom_headers:nil)
      response = get_secret_versions_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List all versions of the specified secret.
    #
    # The full secret identifier and attributes are provided in the response. No
    # values are returned for the secrets. This operations requires the
    # secrets/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_secret_versions_next_with_http_info(next_page_link, custom_headers:nil)
      get_secret_versions_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # List all versions of the specified secret.
    #
    # The full secret identifier and attributes are provided in the response. No
    # values are returned for the secrets. This operations requires the
    # secrets/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_secret_versions_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists deleted secrets for the specified vault.
    #
    # The Get Deleted Secrets operation returns the secrets that have been deleted
    # for a vault enabled for soft-delete. This operation requires the secrets/list
    # permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedSecretListResult] operation results.
    #
    def get_deleted_secrets_next(next_page_link, custom_headers:nil)
      response = get_deleted_secrets_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Lists deleted secrets for the specified vault.
    #
    # The Get Deleted Secrets operation returns the secrets that have been deleted
    # for a vault enabled for soft-delete. This operation requires the secrets/list
    # permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_secrets_next_with_http_info(next_page_link, custom_headers:nil)
      get_deleted_secrets_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # Lists deleted secrets for the specified vault.
    #
    # The Get Deleted Secrets operation returns the secrets that have been deleted
    # for a vault enabled for soft-delete. This operation requires the secrets/list
    # permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_secrets_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedSecretListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List certificates in a specified key vault
    #
    # The GetCertificates operation returns the set of certificates resources in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateListResult] operation results.
    #
    def get_certificates_next(next_page_link, custom_headers:nil)
      response = get_certificates_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List certificates in a specified key vault
    #
    # The GetCertificates operation returns the set of certificates resources in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificates_next_with_http_info(next_page_link, custom_headers:nil)
      get_certificates_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # List certificates in a specified key vault
    #
    # The GetCertificates operation returns the set of certificates resources in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificates_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List certificate issuers for a specified key vault.
    #
    # The GetCertificateIssuers operation returns the set of certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateIssuerListResult] operation results.
    #
    def get_certificate_issuers_next(next_page_link, custom_headers:nil)
      response = get_certificate_issuers_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List certificate issuers for a specified key vault.
    #
    # The GetCertificateIssuers operation returns the set of certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_issuers_next_with_http_info(next_page_link, custom_headers:nil)
      get_certificate_issuers_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # List certificate issuers for a specified key vault.
    #
    # The GetCertificateIssuers operation returns the set of certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_issuers_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateIssuerListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List the versions of a certificate.
    #
    # The GetCertificateVersions operation returns the versions of a certificate in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateListResult] operation results.
    #
    def get_certificate_versions_next(next_page_link, custom_headers:nil)
      response = get_certificate_versions_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List the versions of a certificate.
    #
    # The GetCertificateVersions operation returns the versions of a certificate in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_versions_next_with_http_info(next_page_link, custom_headers:nil)
      get_certificate_versions_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # List the versions of a certificate.
    #
    # The GetCertificateVersions operation returns the versions of a certificate in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_versions_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the deleted certificates in the specified vault currently available for
    # recovery.
    #
    # The GetDeletedCertificates operation retrieves the certificates in the
    # current vault which are in a deleted state and ready for recovery or purging.
    # This operation includes deletion-specific information. This operation
    # requires the certificates/get/list permission. This operation can only be
    # enabled on soft-delete enabled vaults.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedCertificateListResult] operation results.
    #
    def get_deleted_certificates_next(next_page_link, custom_headers:nil)
      response = get_deleted_certificates_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # Lists the deleted certificates in the specified vault currently available for
    # recovery.
    #
    # The GetDeletedCertificates operation retrieves the certificates in the
    # current vault which are in a deleted state and ready for recovery or purging.
    # This operation includes deletion-specific information. This operation
    # requires the certificates/get/list permission. This operation can only be
    # enabled on soft-delete enabled vaults.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_certificates_next_with_http_info(next_page_link, custom_headers:nil)
      get_deleted_certificates_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # Lists the deleted certificates in the specified vault currently available for
    # recovery.
    #
    # The GetDeletedCertificates operation retrieves the certificates in the
    # current vault which are in a deleted state and ready for recovery or purging.
    # This operation includes deletion-specific information. This operation
    # requires the certificates/get/list permission. This operation can only be
    # enabled on soft-delete enabled vaults.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_certificates_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedCertificateListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List storage accounts managed by the specified key vault. This operation
    # requires the storage/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [StorageListResult] operation results.
    #
    def get_storage_accounts_next(next_page_link, custom_headers:nil)
      response = get_storage_accounts_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List storage accounts managed by the specified key vault. This operation
    # requires the storage/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_storage_accounts_next_with_http_info(next_page_link, custom_headers:nil)
      get_storage_accounts_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # List storage accounts managed by the specified key vault. This operation
    # requires the storage/list permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_storage_accounts_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::StorageListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List storage SAS definitions for the given storage account. This operation
    # requires the storage/listsas permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SasDefinitionListResult] operation results.
    #
    def get_sas_definitions_next(next_page_link, custom_headers:nil)
      response = get_sas_definitions_next_async(next_page_link, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # List storage SAS definitions for the given storage account. This operation
    # requires the storage/listsas permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_sas_definitions_next_with_http_info(next_page_link, custom_headers:nil)
      get_sas_definitions_next_async(next_page_link, custom_headers:custom_headers).value!
    end

    #
    # List storage SAS definitions for the given storage account. This operation
    # requires the storage/listsas permission.
    #
    # @param next_page_link [String] The NextLink from the previous successful call
    # to List operation.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_sas_definitions_next_async(next_page_link, custom_headers:nil)
      fail ArgumentError, 'next_page_link is nil' if next_page_link.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Set Headers
      request_headers['x-ms-client-request-id'] = SecureRandom.uuid
      request_headers['accept-language'] = accept_language unless accept_language.nil?
      path_template = '{nextLink}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          skip_encoding_path_params: {'nextLink' => next_page_link},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SasDefinitionListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Retrieves a list of individual key versions with the same key name.
    #
    # The full key identifier, attributes, and tags are provided in the response.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyListResult] operation results.
    #
    def get_key_versions_as_lazy(vault_base_url, key_name, maxresults:nil, custom_headers:nil)
      first_page = get_key_versions_as_lazy_as_lazy(vault_base_url, key_name, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # Retrieves a list of individual key versions with the same key name.
    #
    # The full key identifier, attributes, and tags are provided in the response.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_key_versions_as_lazy_with_http_info(vault_base_url, key_name, maxresults:nil, custom_headers:nil)
      get_key_versions_as_lazy_async(vault_base_url, key_name, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # Retrieves a list of individual key versions with the same key name.
    #
    # The full key identifier, attributes, and tags are provided in the response.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param key_name [String] The name of the key.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_key_versions_as_lazy_async(vault_base_url, key_name, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'key_name is nil' if key_name.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'keys/{key-name}/versions'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'key-name' => key_name},
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a stored key. The LIST operation is applicable to
    # all key types, however only the base key identifier, attributes, and tags are
    # provided in the response. Individual versions of a key are not listed in the
    # response. This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [KeyListResult] operation results.
    #
    def get_keys_as_lazy(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_keys_as_lazy_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a stored key. The LIST operation is applicable to
    # all key types, however only the base key identifier, attributes, and tags are
    # provided in the response. Individual versions of a key are not listed in the
    # response. This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_keys_as_lazy_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_keys_as_lazy_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a stored key. The LIST operation is applicable to
    # all key types, however only the base key identifier, attributes, and tags are
    # provided in the response. Individual versions of a key are not listed in the
    # response. This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_keys_as_lazy_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'keys'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::KeyListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the deleted keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a deleted key. This operation includes
    # deletion-specific information. The Get Deleted Keys operation is applicable
    # for vaults enabled for soft-delete. While the operation can be invoked on any
    # vault, it will return an error if invoked on a non soft-delete enabled vault.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedKeyListResult] operation results.
    #
    def get_deleted_keys_as_lazy(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_deleted_keys_as_lazy_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # Lists the deleted keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a deleted key. This operation includes
    # deletion-specific information. The Get Deleted Keys operation is applicable
    # for vaults enabled for soft-delete. While the operation can be invoked on any
    # vault, it will return an error if invoked on a non soft-delete enabled vault.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_keys_as_lazy_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_deleted_keys_as_lazy_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # Lists the deleted keys in the specified vault.
    #
    # Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
    # contain the public part of a deleted key. This operation includes
    # deletion-specific information. The Get Deleted Keys operation is applicable
    # for vaults enabled for soft-delete. While the operation can be invoked on any
    # vault, it will return an error if invoked on a non soft-delete enabled vault.
    # This operation requires the keys/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_keys_as_lazy_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'deletedkeys'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedKeyListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List secrets in a specified key vault.
    #
    # The Get Secrets operation is applicable to the entire vault. However, only
    # the base secret identifier and its attributes are provided in the response.
    # Individual secret versions are not listed in the response. This operation
    # requires the secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SecretListResult] operation results.
    #
    def get_secrets_as_lazy(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_secrets_as_lazy_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List secrets in a specified key vault.
    #
    # The Get Secrets operation is applicable to the entire vault. However, only
    # the base secret identifier and its attributes are provided in the response.
    # Individual secret versions are not listed in the response. This operation
    # requires the secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_secrets_as_lazy_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_secrets_as_lazy_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List secrets in a specified key vault.
    #
    # The Get Secrets operation is applicable to the entire vault. However, only
    # the base secret identifier and its attributes are provided in the response.
    # Individual secret versions are not listed in the response. This operation
    # requires the secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_secrets_as_lazy_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'secrets'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List all versions of the specified secret.
    #
    # The full secret identifier and attributes are provided in the response. No
    # values are returned for the secrets. This operations requires the
    # secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SecretListResult] operation results.
    #
    def get_secret_versions_as_lazy(vault_base_url, secret_name, maxresults:nil, custom_headers:nil)
      first_page = get_secret_versions_as_lazy_as_lazy(vault_base_url, secret_name, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List all versions of the specified secret.
    #
    # The full secret identifier and attributes are provided in the response. No
    # values are returned for the secrets. This operations requires the
    # secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_secret_versions_as_lazy_with_http_info(vault_base_url, secret_name, maxresults:nil, custom_headers:nil)
      get_secret_versions_as_lazy_async(vault_base_url, secret_name, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List all versions of the specified secret.
    #
    # The full secret identifier and attributes are provided in the response. No
    # values are returned for the secrets. This operations requires the
    # secrets/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param secret_name [String] The name of the secret.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified, the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_secret_versions_as_lazy_async(vault_base_url, secret_name, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'secret_name is nil' if secret_name.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'secrets/{secret-name}/versions'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'secret-name' => secret_name},
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SecretListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists deleted secrets for the specified vault.
    #
    # The Get Deleted Secrets operation returns the secrets that have been deleted
    # for a vault enabled for soft-delete. This operation requires the secrets/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedSecretListResult] operation results.
    #
    def get_deleted_secrets_as_lazy(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_deleted_secrets_as_lazy_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # Lists deleted secrets for the specified vault.
    #
    # The Get Deleted Secrets operation returns the secrets that have been deleted
    # for a vault enabled for soft-delete. This operation requires the secrets/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_secrets_as_lazy_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_deleted_secrets_as_lazy_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # Lists deleted secrets for the specified vault.
    #
    # The Get Deleted Secrets operation returns the secrets that have been deleted
    # for a vault enabled for soft-delete. This operation requires the secrets/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_secrets_as_lazy_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'deletedsecrets'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedSecretListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List certificates in a specified key vault
    #
    # The GetCertificates operation returns the set of certificates resources in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateListResult] operation results.
    #
    def get_certificates_as_lazy(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_certificates_as_lazy_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List certificates in a specified key vault
    #
    # The GetCertificates operation returns the set of certificates resources in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificates_as_lazy_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_certificates_as_lazy_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List certificates in a specified key vault
    #
    # The GetCertificates operation returns the set of certificates resources in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificates_as_lazy_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'certificates'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List certificate issuers for a specified key vault.
    #
    # The GetCertificateIssuers operation returns the set of certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateIssuerListResult] operation results.
    #
    def get_certificate_issuers_as_lazy(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_certificate_issuers_as_lazy_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List certificate issuers for a specified key vault.
    #
    # The GetCertificateIssuers operation returns the set of certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_issuers_as_lazy_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_certificate_issuers_as_lazy_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List certificate issuers for a specified key vault.
    #
    # The GetCertificateIssuers operation returns the set of certificate issuer
    # resources in the specified key vault. This operation requires the
    # certificates/manageissuers/getissuers permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_issuers_as_lazy_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'certificates/issuers'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateIssuerListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List the versions of a certificate.
    #
    # The GetCertificateVersions operation returns the versions of a certificate in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CertificateListResult] operation results.
    #
    def get_certificate_versions_as_lazy(vault_base_url, certificate_name, maxresults:nil, custom_headers:nil)
      first_page = get_certificate_versions_as_lazy_as_lazy(vault_base_url, certificate_name, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List the versions of a certificate.
    #
    # The GetCertificateVersions operation returns the versions of a certificate in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_certificate_versions_as_lazy_with_http_info(vault_base_url, certificate_name, maxresults:nil, custom_headers:nil)
      get_certificate_versions_as_lazy_async(vault_base_url, certificate_name, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List the versions of a certificate.
    #
    # The GetCertificateVersions operation returns the versions of a certificate in
    # the specified key vault. This operation requires the certificates/list
    # permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param certificate_name [String] The name of the certificate.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_certificate_versions_as_lazy_async(vault_base_url, certificate_name, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'certificate_name is nil' if certificate_name.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'certificates/{certificate-name}/versions'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'certificate-name' => certificate_name},
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::CertificateListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # Lists the deleted certificates in the specified vault currently available for
    # recovery.
    #
    # The GetDeletedCertificates operation retrieves the certificates in the
    # current vault which are in a deleted state and ready for recovery or purging.
    # This operation includes deletion-specific information. This operation
    # requires the certificates/get/list permission. This operation can only be
    # enabled on soft-delete enabled vaults.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DeletedCertificateListResult] operation results.
    #
    def get_deleted_certificates_as_lazy(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_deleted_certificates_as_lazy_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # Lists the deleted certificates in the specified vault currently available for
    # recovery.
    #
    # The GetDeletedCertificates operation retrieves the certificates in the
    # current vault which are in a deleted state and ready for recovery or purging.
    # This operation includes deletion-specific information. This operation
    # requires the certificates/get/list permission. This operation can only be
    # enabled on soft-delete enabled vaults.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_deleted_certificates_as_lazy_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_deleted_certificates_as_lazy_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # Lists the deleted certificates in the specified vault currently available for
    # recovery.
    #
    # The GetDeletedCertificates operation retrieves the certificates in the
    # current vault which are in a deleted state and ready for recovery or purging.
    # This operation includes deletion-specific information. This operation
    # requires the certificates/get/list permission. This operation can only be
    # enabled on soft-delete enabled vaults.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deleted_certificates_as_lazy_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'deletedcertificates'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::DeletedCertificateListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List storage accounts managed by the specified key vault. This operation
    # requires the storage/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [StorageListResult] operation results.
    #
    def get_storage_accounts_as_lazy(vault_base_url, maxresults:nil, custom_headers:nil)
      first_page = get_storage_accounts_as_lazy_as_lazy(vault_base_url, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List storage accounts managed by the specified key vault. This operation
    # requires the storage/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_storage_accounts_as_lazy_with_http_info(vault_base_url, maxresults:nil, custom_headers:nil)
      get_storage_accounts_as_lazy_async(vault_base_url, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List storage accounts managed by the specified key vault. This operation
    # requires the storage/list permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_storage_accounts_as_lazy_async(vault_base_url, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'storage'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::StorageListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # List storage SAS definitions for the given storage account. This operation
    # requires the storage/listsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SasDefinitionListResult] operation results.
    #
    def get_sas_definitions_as_lazy(vault_base_url, storage_account_name, maxresults:nil, custom_headers:nil)
      first_page = get_sas_definitions_as_lazy_as_lazy(vault_base_url, storage_account_name, maxresults:maxresults, custom_headers:custom_headers)
      first_page.get_all_items
    end

    #
    # List storage SAS definitions for the given storage account. This operation
    # requires the storage/listsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRestAzure::AzureOperationResponse] HTTP response information.
    #
    def get_sas_definitions_as_lazy_with_http_info(vault_base_url, storage_account_name, maxresults:nil, custom_headers:nil)
      get_sas_definitions_as_lazy_async(vault_base_url, storage_account_name, maxresults:maxresults, custom_headers:custom_headers).value!
    end

    #
    # List storage SAS definitions for the given storage account. This operation
    # requires the storage/listsas permission.
    #
    # @param vault_base_url [String] The vault name, for example
    # https://myvault.vault.azure.net.
    # @param storage_account_name [String] The name of the storage account.
    # @param maxresults [Integer] Maximum number of results to return in a page. If
    # not specified the service will return up to 25 results.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_sas_definitions_as_lazy_async(vault_base_url, storage_account_name, maxresults:nil, custom_headers:nil)
      fail ArgumentError, 'vault_base_url is nil' if vault_base_url.nil?
      fail ArgumentError, 'storage_account_name is nil' if storage_account_name.nil?
      fail ArgumentError, "'storage_account_name' should satisfy the constraint - 'Pattern': '^[0-9a-zA-Z]+$'" if !storage_account_name.nil? && storage_account_name.match(Regexp.new('^^[0-9a-zA-Z]+$$')).nil?
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMaximum': '25'" if !maxresults.nil? && maxresults > 25
      fail ArgumentError, "'maxresults' should satisfy the constraint - 'InclusiveMinimum': '1'" if !maxresults.nil? && maxresults < 1


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'storage/{storage-account-name}/sas'

      request_url = @base_url || self.base_url
    request_url = request_url.gsub('{vaultBaseUrl}', vault_base_url)

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'storage-account-name' => storage_account_name},
          query_params: {'maxresults' => maxresults},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        result.request_id = http_response['x-ms-request-id'] unless http_response['x-ms-request-id'].nil?
        result.correlation_request_id = http_response['x-ms-correlation-request-id'] unless http_response['x-ms-correlation-request-id'].nil?
        result.client_request_id = http_response['x-ms-client-request-id'] unless http_response['x-ms-client-request-id'].nil?
        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Azure::KeyVault::V2016_10_01::Models::SasDefinitionListResult.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end


    private
    #
    # Adds telemetry information.
    #
    def add_telemetry
        sdk_information = 'azure_key_vault'
        sdk_information = "#{sdk_information}/0.18.0"
        add_user_agent_information(sdk_information)
    end
  end
end
